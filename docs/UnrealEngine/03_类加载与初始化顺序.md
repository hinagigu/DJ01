# 03 - 类加载与初始化顺序

## 概述

Unreal Engine 的对象系统是整个引擎的核心基础。理解 UClass、CDO（Class Default Object）、以及各类对象的初始化顺序，对于深入掌握 UE 开发至关重要。

本文档将深入分析：
- UObject 反射系统的基础
- CDO 的创建和作用
- UClass 的注册流程
- 核心游戏类的初始化时序

---

## 1. UObject 反射系统基础

### 1.1 反射系统架构

```mermaid
classDiagram
    class UObjectBase {
        -EObjectFlags ObjectFlags
        -int32 InternalIndex
        -UClass* ClassPrivate
        -FName NamePrivate
        -UObject* OuterPrivate
    }
    
    class UObjectBaseUtility {
        +GetClass()
        +GetOuter()
        +GetName()
        +GetPathName()
    }
    
    class UObject {
        +PostInitProperties()
        +PostLoad()
        +BeginDestroy()
        +FinishDestroy()
        +Serialize()
    }
    
    class UField {
        +UField* Next
    }
    
    class UStruct {
        +UStruct* SuperStruct
        +UField* Children
        +int32 PropertiesSize
    }
    
    class UClass {
        +UObject* ClassDefaultObject
        +UClass* ClassWithin
        +FName ClassConfigName
        +TArray~FImplementedInterface~ Interfaces
        +ClassConstructor
        +ClassVTableHelperCtorCaller
    }
    
    UObjectBase <|-- UObjectBaseUtility
    UObjectBaseUtility <|-- UObject
    UObject <|-- UField
    UField <|-- UStruct
    UStruct <|-- UClass
```

### 1.2 关键宏定义

UE 通过一系列宏来实现反射系统的自动注册：

```cpp
// 声明类的反射信息
UCLASS()
class MYMODULE_API UMyClass : public UObject
{
    GENERATED_BODY()  // 展开为反射相关的声明
    
    UPROPERTY()
    int32 MyProperty;
    
    UFUNCTION()
    void MyFunction();
};
```

**GENERATED_BODY() 宏展开后包含：**

```cpp
// 简化展示核心内容
public:
    // 静态类获取函数
    static UClass* StaticClass();
    
    // 类型信息
    typedef UMyClass ThisClass;
    typedef UObject Super;
    
    // 构造函数相关
    static void __DefaultConstructor(const FObjectInitializer& X);
    
private:
    // 禁用拷贝
    UMyClass(const UMyClass&) = delete;
    UMyClass& operator=(const UMyClass&) = delete;
```

---

## 2. CDO（Class Default Object）

### 2.1 CDO 的概念与作用

**CDO** 是每个 UClass 的"原型对象"，用于：

1. **存储类的默认属性值** - 新实例复制 CDO 的属性作为初始值
2. **支持属性编辑器** - 蓝图和编辑器读取 CDO 来显示默认值
3. **序列化优化** - 只序列化与 CDO 不同的属性值
4. **反射查询** - 运行时查询类的默认行为

```mermaid
flowchart LR
    subgraph "UClass"
        CDO["CDO<br/>ClassDefaultObject"]
    end
    
    subgraph "实例化"
        Inst1["Instance 1"]
        Inst2["Instance 2"]
        Inst3["Instance 3"]
    end
    
    CDO -->|"复制默认值"| Inst1
    CDO -->|"复制默认值"| Inst2
    CDO -->|"复制默认值"| Inst3
    
    style CDO fill:#f96,stroke:#333
```

### 2.2 CDO 创建流程

```mermaid
sequenceDiagram
    participant UClass
    participant CDO as CDO Object
    participant Constructor
    
    UClass->>UClass: GetDefaultObject(bCreateIfNeeded=true)
    
    alt CDO 不存在
        UClass->>UClass: CreateDefaultObject()
        UClass->>CDO: StaticAllocateObject()
        Note over CDO: 分配内存，设置类型信息
        
        UClass->>Constructor: ClassConstructor(FObjectInitializer)
        Constructor->>CDO: 执行 C++ 构造函数
        
        UClass->>CDO: PostInitProperties()
        Note over CDO: 属性初始化完成
        
        UClass->>CDO: PostCDOContruct()
        Note over CDO: CDO 特殊初始化
    end
    
    UClass-->>UClass: 返回 CDO 指针
```

### 2.3 CDO 在代码中的体现

```cpp
// UClass 中 CDO 的定义
// Engine/Source/Runtime/CoreUObject/Public/UObject/Class.h

class UClass : public UStruct
{
    // ...
    
    /** 类的默认对象 */
    UObject* ClassDefaultObject;
    
public:
    /**
     * 获取此类的默认对象
     * @param bCreateIfNeeded - 如果 CDO 不存在是否创建
     */
    UObject* GetDefaultObject(bool bCreateIfNeeded = true) const
    {
        if (ClassDefaultObject == nullptr && bCreateIfNeeded)
        {
            const_cast<UClass*>(this)->CreateDefaultObject();
        }
        return ClassDefaultObject;
    }
    
    // 模板版本，自动转型
    template<class T>
    T* GetDefaultObject() const
    {
        return (T*)GetDefaultObject(true);
    }
};
```

### 2.4 CDO 与普通实例的区别

| 特性 | CDO | 普通实例 |
|-----|-----|---------|
| 创建时机 | 类注册时（或首次访问时） | 运行时按需创建 |
| 数量 | 每个 UClass 仅一个 | 无限制 |
| 生命周期 | 与 UClass 相同 | 由 GC 管理 |
| 序列化 | 通常不序列化 | 正常序列化 |
| 标志位 | RF_ClassDefaultObject | 无此标志 |
| Outer | 通常是 GetTransientPackage() | 根据创建上下文 |

---

## 3. UClass 注册流程

### 3.1 静态注册架构

```mermaid
flowchart TB
    subgraph "编译时"
        UHT["UnrealHeaderTool<br/>生成 .generated.h"]
        MACRO["IMPLEMENT_CLASS 宏<br/>定义静态注册器"]
    end
    
    subgraph "程序启动"
        STATIC["静态初始化阶段<br/>TClassCompiledInDefer"]
        PENDING["PendingRegistrants<br/>待注册队列"]
    end
    
    subgraph "引擎初始化"
        PROCESS["ProcessNewlyLoadedUObjects()"]
        REGISTER["UClassRegisterAllCompiledInClasses()"]
        CONSTRUCT["构造 UClass 对象"]
        CDO_CREATE["创建 CDO"]
    end
    
    UHT --> MACRO
    MACRO --> STATIC
    STATIC --> PENDING
    PENDING --> PROCESS
    PROCESS --> REGISTER
    REGISTER --> CONSTRUCT
    CONSTRUCT --> CDO_CREATE
```

### 3.2 关键注册结构

```cpp
// 简化的注册信息结构
struct FClassRegisterCompiledInInfo
{
    // 类名（用于查找）
    const TCHAR* Name;
    
    // 类的外部对象（通常是 Package）
    UClass* (*OuterRegister)();
    
    // 获取静态类的函数指针
    UClass* (*InnerRegister)();
    
    // 包名
    const TCHAR* PackageName;
};

// IMPLEMENT_CLASS 宏展开（简化）
#define IMPLEMENT_CLASS(TClass, TPackage) \
    static FClassRegisterCompiledInInfo AutoInitialize##TClass( \
        TEXT(#TClass), \
        &TClass::StaticPackage, \
        &TClass::StaticClass, \
        TEXT(#TPackage) \
    );
```

### 3.3 延迟注册机制

```cpp
// Engine/Source/Runtime/CoreUObject/Private/UObject/UObjectGlobals.cpp

/** 待注册的类列表 */
static TArray<FClassRegisterCompiledInInfo>& GetDeferredClassRegistration()
{
    static TArray<FClassRegisterCompiledInInfo> DeferredClassRegistration;
    return DeferredClassRegistration;
}

/** 处理待注册的类 */
void UClassRegisterAllCompiledInClasses()
{
    TArray<FClassRegisterCompiledInInfo>& DeferredClassRegistration = 
        GetDeferredClassRegistration();
    
    for (const FClassRegisterCompiledInInfo& Info : DeferredClassRegistration)
    {
        // 调用 InnerRegister 创建 UClass
        UClass* Class = Info.InnerRegister();
        // ...
    }
    
    DeferredClassRegistration.Empty();
}
```

### 3.4 注册时序图

```mermaid
sequenceDiagram
    participant Main as main()
    participant Static as 静态初始化
    participant Module as ModuleManager
    participant CoreUObject
    participant UClass
    
    Note over Main,Static: 程序加载阶段
    
    Static->>Static: 执行全局静态构造函数
    Static->>Static: FClassRegisterCompiledInInfo 添加到队列
    
    Note over Main,Module: FEngineLoop::PreInit
    
    Main->>CoreUObject: LoadCoreModules()
    CoreUObject->>CoreUObject: ProcessNewlyLoadedUObjects()
    CoreUObject->>UClass: UClassRegisterAllCompiledInClasses()
    
    loop 对每个待注册类
        UClass->>UClass: StaticClass() 首次调用
        UClass->>UClass: 创建 UClass 对象
        UClass->>UClass: 设置 SuperClass, Properties, Functions
    end
    
    Note over Main,Module: 模块加载
    
    Main->>Module: LoadModule("MyModule")
    Module->>Module: 执行 DLL 静态初始化
    Module->>CoreUObject: ProcessNewlyLoadedUObjects()
    CoreUObject->>UClass: 注册模块中的新类
```

---

## 4. 核心游戏类初始化顺序

### 4.1 完整初始化时序

```mermaid
sequenceDiagram
    participant Engine as UGameEngine
    participant GI as UGameInstance
    participant World as UWorld
    participant GM as AGameModeBase
    participant GS as AGameStateBase
    participant PC as APlayerController
    participant Pawn as APawn
    
    Note over Engine: Init 阶段
    Engine->>GI: CreateGameInstance()
    GI->>GI: 构造函数
    GI->>GI: Init()
    
    Engine->>Engine: Start()
    Engine->>GI: StartGameInstance()
    
    Note over World: 地图加载
    GI->>World: LoadMap()
    World->>World: InitWorld()
    
    World->>GM: SpawnActor<AGameModeBase>()
    GM->>GM: 构造函数
    GM->>GM: PostInitializeComponents() 
    
    Note over GM,GS: GameState 创建
    GM->>GS: SpawnActor<AGameStateBase>()
    GS->>GS: 构造函数
    GS->>GS: PostInitializeComponents()
    
    World->>World: InitializeActorsForPlay()
    
    Note over PC: 玩家加入
    GM->>PC: Login() -> SpawnPlayerController()
    PC->>PC: 构造函数
    PC->>PC: PostInitializeComponents()
    
    GM->>Pawn: SpawnDefaultPawnFor()
    Pawn->>Pawn: 构造函数
    Pawn->>Pawn: PostInitializeComponents()
    
    PC->>Pawn: Possess()
    
    Note over World: BeginPlay 阶段
    World->>GM: BeginPlay()
    World->>GS: BeginPlay()
    World->>PC: BeginPlay()
    World->>Pawn: BeginPlay()
```

### 4.2 各类初始化详解

#### UGameInstance 初始化

```cpp
// Engine/Source/Runtime/Engine/Private/GameInstance.cpp

void UGameInstance::Init()
{
    // 获取子系统集合
    SubsystemCollection.Initialize(this);
    
    // 接收引擎启动完成通知
    ReceiveInit();  // 蓝图事件
}

void UGameInstance::StartGameInstance()
{
    // 获取启动地图
    FURL DefaultURL;
    DefaultURL.Map = GetDefaultMap();
    
    // 浏览到默认地图
    FString Error;
    if (GetEngine()->Browse(*WorldContext, DefaultURL, Error) == EBrowseReturnVal::Pending)
    {
        // 地图加载中...
    }
}
```

**初始化时机：**
| 函数 | 调用时机 | 用途 |
|-----|---------|-----|
| 构造函数 | CreateGameInstance() 内 | 基础成员初始化 |
| Init() | 构造后立即 | 初始化子系统 |
| StartGameInstance() | UGameEngine::Start() | 开始加载地图 |
| OnStart() | 地图加载完成后 | 游戏正式开始 |

#### AGameModeBase 初始化

```cpp
// Engine/Source/Runtime/Engine/Private/GameModeBase.cpp

void AGameModeBase::PreInitializeComponents()
{
    Super::PreInitializeComponents();
    
    // 创建 GameState - 这是最早的时机
    FActorSpawnParameters SpawnInfo;
    SpawnInfo.Instigator = GetInstigator();
    SpawnInfo.ObjectFlags |= RF_Transient;
    
    GameState = GetWorld()->SpawnActor<AGameStateBase>(
        GameStateClass, 
        SpawnInfo
    );
    
    // 关联
    GetWorld()->SetGameState(GameState);
}

void AGameModeBase::InitGame(const FString& MapName, 
                              const FString& Options, 
                              FString& ErrorMessage)
{
    // 解析游戏选项
    // 此时 GameState 已存在
}
```

#### AGameStateBase 初始化

```cpp
// GameState 的关键初始化点

void AGameStateBase::PostInitializeComponents()
{
    Super::PostInitializeComponents();
    
    // 设置 GameMode 引用（服务器端）
    SetReplicates(true);
    
    // 初始化玩家数组
    PlayerArray.Reset();
}

void AGameStateBase::BeginPlay()
{
    Super::BeginPlay();
    
    // 此时所有玩家控制器已创建
    // 可以安全地进行游戏逻辑初始化
}
```

### 4.3 初始化顺序保证

```mermaid
flowchart TB
    subgraph "阶段1: 引擎初始化"
        E1["UGameEngine::Init()"]
        E2["UGameInstance 创建"]
        E3["UGameInstance::Init()"]
    end
    
    subgraph "阶段2: 地图加载"
        M1["LoadMap()"]
        M2["UWorld::InitWorld()"]
        M3["SetGameMode()"]
        M4["GameMode 构造"]
    end
    
    subgraph "阶段3: GameState"
        G1["GameMode::PreInitializeComponents()"]
        G2["GameState Spawn"]
        G3["GameState::PostInitializeComponents()"]
    end
    
    subgraph "阶段4: Actors 初始化"
        A1["InitializeActorsForPlay()"]
        A2["所有 Actor 的 PreInitializeComponents"]
        A3["所有 Actor 的 PostInitializeComponents"]
    end
    
    subgraph "阶段5: 玩家创建"
        P1["Login/SpawnPlayerController"]
        P2["SpawnDefaultPawn"]
        P3["Possess"]
    end
    
    subgraph "阶段6: BeginPlay"
        B1["World::BeginPlay()"]
        B2["所有 Actor BeginPlay"]
    end
    
    E1 --> E2 --> E3
    E3 --> M1 --> M2 --> M3 --> M4
    M4 --> G1 --> G2 --> G3
    G3 --> A1 --> A2 --> A3
    A3 --> P1 --> P2 --> P3
    P3 --> B1 --> B2
```

---

## 5. 对象构造流程

### 5.1 NewObject 流程

```cpp
// 使用示例
UMyObject* Obj = NewObject<UMyObject>(Outer, UMyObject::StaticClass(), NAME_None);
```

```mermaid
sequenceDiagram
    participant Caller
    participant NewObject
    participant StaticAlloc as StaticAllocateObject
    participant StaticConst as StaticConstructObject
    participant FObjectInit as FObjectInitializer
    participant Constructor
    participant Object
    
    Caller->>NewObject: NewObject<T>(Outer, Class, Name)
    NewObject->>StaticAlloc: StaticAllocateObject()
    
    Note over StaticAlloc: 内存分配
    StaticAlloc->>StaticAlloc: 从对象池或 malloc 分配
    StaticAlloc->>StaticAlloc: 设置 UObject 基础字段
    StaticAlloc-->>NewObject: 返回原始内存指针
    
    NewObject->>StaticConst: StaticConstructObject_Internal()
    
    StaticConst->>FObjectInit: FObjectInitializer 构造
    Note over FObjectInit: 记录当前构造的对象信息
    
    StaticConst->>Constructor: InternalConstructor<T>()
    Constructor->>Object: new(内存) T(FObjectInitializer)
    Note over Object: C++ 构造函数执行
    
    StaticConst->>Object: PostInitProperties()
    Note over Object: UObject 通用初始化
    
    alt 是资产对象
        StaticConst->>Object: PostLoad()
        Note over Object: 资产加载后处理
    end
    
    StaticConst-->>Caller: 返回构造完成的对象
```

### 5.2 SpawnActor 流程

```cpp
// Actor 生成示例
FActorSpawnParameters Params;
Params.Owner = this;
AMyActor* Actor = GetWorld()->SpawnActor<AMyActor>(ActorClass, Location, Rotation, Params);
```

```mermaid
sequenceDiagram
    participant World as UWorld
    participant SpawnActor
    participant NewObject
    participant Actor as AActor
    participant Components
    
    World->>SpawnActor: SpawnActor<T>()
    
    SpawnActor->>SpawnActor: SpawnActorDeferred()
    Note over SpawnActor: 检查碰撞、验证类型
    
    SpawnActor->>NewObject: NewObject<AActor>()
    NewObject-->>SpawnActor: 返回 Actor 指针
    
    Note over Actor: 此时 Actor 已构造<br/>但组件未初始化
    
    SpawnActor->>Actor: PostSpawnInitialize()
    Actor->>Actor: PostActorCreated()
    Actor->>Actor: ExecuteConstruction()
    Note over Actor: 运行构造脚本
    
    Actor->>Components: RegisterAllComponents()
    loop 每个组件
        Components->>Components: RegisterComponent()
        Components->>Components: OnRegister()
    end
    
    Actor->>Actor: PreInitializeComponents()
    Actor->>Actor: InitializeComponents()
    Actor->>Actor: PostInitializeComponents()
    
    alt 世界已开始
        Actor->>Actor: BeginPlay()
    end
    
    SpawnActor-->>World: 返回生成的 Actor
```

### 5.3 构造函数 vs PostInitProperties

| 特性 | C++ 构造函数 | PostInitProperties |
|-----|------------|-------------------|
| 调用时机 | 内存分配后立即 | 构造函数完成后 |
| 可用信息 | 仅 C++ 成员 | UObject 系统已就绪 |
| CDO 访问 | ❌ 不安全 | ✅ 可以访问 |
| Outer 访问 | ❌ 不安全 | ✅ 可以访问 |
| 推荐用途 | 简单成员初始化 | 需要 UObject 功能的初始化 |

```cpp
// 正确使用示例
UMyComponent::UMyComponent()
{
    // ✅ 简单值初始化
    bAutoActivate = true;
    PrimaryComponentTick.bCanEverTick = true;
}

void UMyComponent::PostInitProperties()
{
    Super::PostInitProperties();
    
    // ✅ 需要 Outer 的操作
    if (AActor* Owner = GetOwner())
    {
        // 可以安全访问 Owner
    }
    
    // ✅ 需要 CDO 的操作
    if (!HasAnyFlags(RF_ClassDefaultObject))
    {
        // 仅对实例执行，跳过 CDO
    }
}
```

---

## 6. 模块加载时的类注册

### 6.1 模块加载与类注册的关系

```mermaid
flowchart TB
    subgraph "模块 A（先加载）"
        A_DLL["ModuleA.dll 加载"]
        A_Static["静态初始化<br/>类注册信息入队"]
        A_Module["IModuleInterface::StartupModule()"]
    end
    
    subgraph "处理新类"
        Process["ProcessNewlyLoadedUObjects()"]
        Register["注册 ModuleA 的类"]
        CDO_A["创建 CDO"]
    end
    
    subgraph "模块 B（后加载）"
        B_DLL["ModuleB.dll 加载"]
        B_Static["静态初始化"]
        B_Module["StartupModule()"]
    end
    
    subgraph "处理 B 的类"
        Process2["ProcessNewlyLoadedUObjects()"]
        Register2["注册 ModuleB 的类"]
        CDO_B["创建 CDO"]
    end
    
    A_DLL --> A_Static --> A_Module
    A_Module --> Process --> Register --> CDO_A
    CDO_A --> B_DLL
    B_DLL --> B_Static --> B_Module
    B_Module --> Process2 --> Register2 --> CDO_B
```

### 6.2 跨模块类依赖

```cpp
// 如果 ModuleB 的类继承自 ModuleA 的类
// ModuleA 必须先加载

// ModuleB.Build.cs
public class ModuleB : ModuleRules
{
    public ModuleB(ReadOnlyTargetRules Target) : base(Target)
    {
        // 声明依赖，确保加载顺序
        PublicDependencyModuleNames.AddRange(new string[] {
            "ModuleA"  // ModuleA 会先加载
        });
    }
}
```

---

## 7. 调试技巧

### 7.1 常用调试命令

```cpp
// 控制台命令
Obj List Class=MyClass     // 列出某类的所有实例
Obj Classes                 // 列出所有已注册的类
Obj Refs Class=MyClass     // 查看对象引用关系

// 代码中
UE_LOG(LogTemp, Log, TEXT("CDO: %s"), *MyClass::StaticClass()->GetDefaultObject()->GetName());
```

### 7.2 初始化断点建议

调试初始化流程时，建议在以下位置设置断点：

| 断点位置 | 用途 |
|---------|-----|
| `UGameInstance::Init()` | GameInstance 初始化开始 |
| `UWorld::SetGameMode()` | GameMode 创建时机 |
| `AGameModeBase::PreInitializeComponents()` | GameState 创建时机 |
| `AActor::PostInitializeComponents()` | Actor 初始化完成 |
| `AActor::BeginPlay()` | 游戏逻辑开始 |

---

## 总结

### 关键要点

1. **CDO 是类的原型** - 每个 UClass 有且仅有一个 CDO，用于存储默认值
2. **延迟注册机制** - 类在模块加载时注册，而非程序启动时立即注册
3. **严格的初始化顺序** - GameInstance → GameMode → GameState → PlayerController → Pawn
4. **构造函数限制** - C++ 构造函数中不要访问 UObject 系统功能，应使用 PostInitProperties

### 核心初始化函数调用顺序

```
[对象创建]
1. 内存分配
2. C++ 构造函数
3. PostInitProperties()

[Actor 特有]
4. PostActorCreated() 或 PostLoad()
5. RegisterAllComponents()
6. PreInitializeComponents()
7. InitializeComponents()
8. PostInitializeComponents()

[游戏开始]
9. BeginPlay()
```

---

> 下一篇：[04 - Actor生命周期](./04_Actor生命周期.md)