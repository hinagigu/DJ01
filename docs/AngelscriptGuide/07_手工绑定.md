# 第7章：手工绑定详解

## 绑定声明

```cpp
// 模板方式（推荐）
auto FBox_ = FAngelscriptBinds::ValueClass<FBox>("FBox", Flags);

// 手动指定大小
auto FBox_ = FAngelscriptBinds::ValueClass("FBox", Flags, sizeof(FBox));

// 引用类型
auto MyClass_ = FAngelscriptBinds::ReferenceClass("MyClass", MyClass::StaticClass());
```

## 构造函数绑定

```cpp
// 默认构造函数
FVector_.Constructor("void f()", [](FVector* Address)
{
    new(Address) FVector();  // placement new
});
SCRIPT_TRIVIAL_NATIVE_CONSTRUCTOR(FVector_, "FVector");

// 带参数的构造函数
FVector_.Constructor("void f(float64 X, float64 Y, float64 Z)", 
    [](FVector* Address, double X, double Y, double Z)
{
    new(Address) FVector(X, Y, Z);
});

// 拷贝构造函数
FVector_.Constructor("void f(const FVector& Other)",
    [](FVector* Address, const FVector& Other)
{
    new(Address) FVector(Other);
});
```

### placement new 解释

```cpp
// 普通 new：分配内存 + 调用构造函数
FVector* ptr = new FVector(1, 2, 3);

// placement new：只调用构造函数，使用已有内存
void* memory = AllocateMemory(sizeof(FVector));
FVector* ptr = new(memory) FVector(1, 2, 3);  // 在 memory 地址构造

// 在 AS 绑定中，Address 是 AS 引擎分配的内存
// 我们只需要在这个地址上构造 C++ 对象
```

## 属性绑定

```cpp
// 简单属性
FVector_.Property("float64 X", &FVector::X);
FVector_.Property("float64 Y", &FVector::Y);
FVector_.Property("float64 Z", &FVector::Z);

// 注意类型映射：
// C++ float  -> AS float32
// C++ double -> AS float64

// 位域（BitField）不能直接绑定，需要 Getter/Setter
// C++: uint32 bIsEnabled : 1;
// 必须写成：
MyClass_.Method("bool GetIsEnabled() const", ...);
MyClass_.Method("void SetIsEnabled(bool Value)", ...);
```

## 方法绑定

```cpp
// 使用宏（推荐）
FVector_.Method("float64 Size() const", METHOD_TRIVIAL(FVector, Size));
FVector_.Method("FVector GetSafeNormal() const", 
                METHOD_TRIVIAL(FVector, GetSafeNormal));

// 重载函数需要 METHODPR_TRIVIAL 指定签名
FVector_.Method("FVector opAdd(const FVector& Other) const",
    METHODPR_TRIVIAL(FVector, FVector, operator+, (const FVector&) const));

// Lambda 方式
FVector_.Method("FString ToString() const", [](const FVector& Self) -> FString
{
    return Self.ToString();
});

// 外部函数作为成员方法
FVector_.Method("void Normalize()", &MyVectorHelpers::Normalize);
```

## 运算符绑定

AngelScript 支持运算符重载，使用特定的方法名：

| 运算符 | AS 方法名 | 签名示例 |
|--------|----------|----------|
| `=` | `opAssign` | `T& opAssign(const T&)` |
| `==` | `opEquals` | `bool opEquals(const T&) const` |
| `!=` | 自动由 opEquals 推导 | - |
| `<` `>` `<=` `>=` | `opCmp` | `int opCmp(const T&) const` |
| `+` | `opAdd` | `T opAdd(const T&) const` |
| `-` | `opSub` | `T opSub(const T&) const` |
| `*` | `opMul` | `T opMul(const T&) const` |
| `/` | `opDiv` | `T opDiv(const T&) const` |
| `+=` | `opAddAssign` | `T& opAddAssign(const T&)` |
| `[]` | `opIndex` | `T& opIndex(int)` |

```cpp
// 比较运算符
FVector_.Method("bool opEquals(const FVector& Other) const",
    [](const FVector& Self, const FVector& Other) -> bool
{
    return Self == Other;
});

// opCmp 返回值：
// < 0: Self < Other
// = 0: Self == Other
// > 0: Self > Other
FVector_.Method("int opCmp(const FVector& Other) const",
    [](const FVector& Self, const FVector& Other) -> int
{
    if (Self.X < Other.X) return -1;
    if (Self.X > Other.X) return 1;
    // ... 比较 Y, Z
    return 0;
});

// 算术运算符
FVector_.Method("FVector opAdd(const FVector& Other) const",
    METHODPR_TRIVIAL(FVector, FVector, operator+, (const FVector&) const));

FVector_.Method("FVector& opAddAssign(const FVector& Other)",
    METHODPR_TRIVIAL(FVector&, FVector, operator+=, (const FVector&)));
```

## 全局函数和变量

```cpp
// 全局函数
FAngelscriptBinds::BindGlobalFunction(
    "AActor SpawnActor(UClass Class, FTransform Transform)",
    &MyHelpers::SpawnActor
);

// 带命名空间
{
    FAngelscriptBinds::FNamespace ns("Math");
    
    FAngelscriptBinds::BindGlobalFunction(
        "float32 Sin(float32 Value)",
        &FMath::Sin
    );
}
// AS 中使用: Math::Sin(1.0f)

// 全局变量
{
    FAngelscriptBinds::FNamespace ns("FVector");
    
    FAngelscriptBinds::BindGlobalVariable(
        "const FVector ZeroVector",
        &FVector::ZeroVector
    );
}
// AS 中使用: FVector::ZeroVector
```

## 枚举绑定

```cpp
AS_FORCE_LINK const FAngelscriptBinds::FBind Bind_ENetMode(
    FAngelscriptBinds::EOrder::Early, 
    []
{
    auto NetMode_ = FAngelscriptBinds::Enum("ENetMode");
    
    NetMode_["NM_Client"]          = ENetMode::NM_Client;
    NetMode_["NM_DedicatedServer"] = ENetMode::NM_DedicatedServer;
    NetMode_["NM_ListenServer"]    = ENetMode::NM_ListenServer;
    NetMode_["NM_Standalone"]      = ENetMode::NM_Standalone;
    NetMode_["NM_MAX"]             = ENetMode::NM_MAX;
});
```

## 强制绑定未标记的类型

```cpp
// 强制绑定 USTRUCT
#define FORCE_BIND_USTRUCT(TypeToBind) \
AS_FORCE_LINK const FAngelscriptBinds::FBind ForceBoundUStruct_##TypeToBind( \
    (int32)FAngelscriptBinds::EOrder::Early - 1, \
    [] \
{ \
    UField* Field = TypeToBind::StaticStruct(); \
    Field->SetMetaData(TEXT("ForceAngelscriptBind"), TEXT("")); \
});

// 使用
FORCE_BIND_USTRUCT(FMyPrivateStruct)

// 强制绑定 UCLASS
#define FORCE_BIND_UCLASS(TypeToBind) \
AS_FORCE_LINK const FAngelscriptBinds::FBind ForceBoundUClass_##TypeToBind( \
    (int32)FAngelscriptBinds::EOrder::Early - 1, \
    [] \
{ \
    UField* Field = TypeToBind::StaticClass(); \
    Field->SetMetaData(TEXT("BlueprintType"), TEXT("true")); \
});
```

---

**上一章**: [06_UScriptStruct绑定.md](./06_UScriptStruct绑定.md)  
**下一章**: [08_泛型模板绑定.md](./08_泛型模板绑定.md) - 学习模板类型的高级绑定