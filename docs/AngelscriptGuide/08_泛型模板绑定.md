# 第8章：泛型与模板绑定

## 模板类型声明

```cpp
// TOptional<T> 绑定示例
FBindFlags Flags;
Flags.bTemplate = true;
Flags.TemplateType = "<class T>";
Flags.ExtraFlags |= asOBJ_TEMPLATE_SUBTYPE_DETERMINES_SIZE;  // 大小由 T 决定
Flags.Alignment = 1;

auto TOptional_ = FAngelscriptBinds::ValueClass("TOptional<class T>", sizeof(bool), Flags);
```

## 模板回调（TemplateCallback）

当 AS 代码中使用具体类型（如 `TOptional<int>`）时，会触发回调：

```cpp
TOptional_.TemplateCallback(
    "bool f(int&in Type, int&out ErrorMessage)",
    [](asITypeInfo* TemplateType, asCString* ErrorMessage) -> bool
{
    // 验证模板参数是否有效
    return FOptionalOperations::ValidateOptionalOperations(
        TemplateType, ErrorMessage) != nullptr;
});

// 验证函数实现
FOptionalOperations* FOptionalOperations::ValidateOptionalOperations(
    asITypeInfo* TemplateType, asCString* ErrorMessage)
{
    // 检查是否已有操作对象
    if (auto* Ops = static_cast<FOptionalOperations*>(TemplateType->GetUserData()))
    {
        return Ops->bValid ? Ops : nullptr;
    }
    
    // 获取子类型信息
    const FAngelscriptTypeUsage Type = 
        FAngelscriptTypeUsage::FromTypeId(TemplateType->GetSubTypeId(0));
    
    // 验证子类型
    if (!Type.CanBeTemplateSubType())
    {
        if (ErrorMessage != nullptr)
            *ErrorMessage = "Containers cannot be nested in other containers";
        return nullptr;
    }
    
    // 创建并存储操作对象
    FOptionalOperations* Ops = new FOptionalOperations(Type);
    TemplateType->SetUserData(Ops);
    
    return Ops->bValid ? Ops : nullptr;
}
```

## 动态大小计算

```cpp
// 注册大小计算器
FAngelscriptManager::Get().Engine->TemplateSizeCalculatorFunctions.Add(
    (asCObjectType*)TOptional_.GetTypeInfo(), 
    &CalculateOptionalSize
);

static int CalculateOptionalSize(asITypeInfo* TemplateType)
{
    // 获取子类型
    int SubTypeId = TemplateType->GetSubTypeId(0);
    FAngelscriptTypeUsage SubType = FAngelscriptTypeUsage::FromTypeId(SubTypeId);
    
    // 计算实际大小
    int SubTypeSize = SubType.GetSize();
    return sizeof(bool) + SubTypeSize;  // isSet + value
}
```

## 泛型函数绑定

使用 `?` 作为泛型参数：

```cpp
// ? 在 C++ 端对应两个参数：void* 和 int TypeId
FAngelscriptBinds::BindGlobalFunction(
    "FName GetTypeName(const ?&in Anything)",
    &UReflectLibrary::GetTypeName
);

// C++ 实现
FName UReflectLibrary::GetTypeName(void* Data, int TypeId)
{
    if (TypeId < 0) return NAME_None;
    
    const asCScriptEngine* Engine = FAngelscriptManager::Get().Engine;
    
    if (TypeId > asTYPEID_LAST_PRIMITIVE)
    {
        // 非基础类型：从 TypeInfo 获取名称
        asCTypeInfo* Info = (asCTypeInfo*)Engine->GetTypeInfoById(TypeId);
        if (!Info) return NAME_None;
        return Info->GetName();
    }
    
    // 基础类型：使用 TypeUsage
    const FAngelscriptTypeUsage Usage = FAngelscriptTypeUsage::FromTypeId(TypeId);
    return FName(Usage.Type->GetAngelscriptTypeName(Usage));
}
```

### 泛型参数修饰符

| 修饰符 | 说明 | 适用场景 |
|--------|------|----------|
| `?&in` | 可接受任何输入（不含 const） | 读取参数 |
| `const ?&in` | 可接受任何输入（含 const） | 只读参数 |
| `?&out` | 只接受引用，不接受临时值 | 输出参数 |

## GenericMethod 绑定

用于批量绑定多种函数签名到同一 C++ 函数：

```cpp
// 所有委托的 Broadcast 都用同一个 C++ 函数处理
Delegate_.GenericMethod(
    FAngelscriptType::BuildFunctionDeclaration(
        ReturnType, TEXT("Broadcast"), ArgumentTypes, 
        ArgumentNames, ArgumentDefaults, true),
    &CallSparseDelegate, 
    Sig  // 用户数据，包含函数签名信息
);

// C++ 处理函数
void CallSparseDelegate(asIScriptGeneric* InGeneric)
{
    asCGeneric* Generic = static_cast<asCGeneric*>(InGeneric);
    
    // 获取函数签名信息
    auto* Function = Generic->GetFunction();
    auto* Sig = (FBlueprintEventSignature*)Function->GetUserData();
    
    // 获取 this 指针
    void* Object = Generic->GetObject();
    
    // 获取参数
    for (int32 Arg = 0; Arg < Sig->ArgCount; ++Arg)
    {
        void* ArgPtr = Generic->GetAddressOfArg(Arg);
        // 处理参数...
    }
    
    // 处理返回值
    if (Sig->ReturnType.IsValid())
    {
        void* ReturnPtr = Generic->GetAddressOfReturnLocation();
        // 设置返回值...
    }
}
```

---

**上一章**: [07_手工绑定.md](./07_手工绑定.md)  
**下一章**: [09_内存模型.md](./09_内存模型.md) - 深入理解内存管理和生命周期