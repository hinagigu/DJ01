# 第10章：实战案例

## 案例 1：绑定自定义 Plain Struct

```cpp
// 1. 定义类型描述
struct FAngelscriptType_FObjectKey : TAngelscriptCppType<FObjectKey>
{
    FString GetAngelscriptTypeName() const override 
    { 
        return TEXT("FObjectKey"); 
    }
    
    bool GetCppForm(const FAngelscriptTypeUsage& Usage, FCppForm& OutCppForm) const override
    {
        OutCppForm.CppType = GetAngelscriptTypeName();
        return true;
    }
};

// 2. 声明绑定
AS_FORCE_LINK FAngelscriptBinds::FBind Bind_FObjectKey_Declaration(
    (int32)FAngelscriptBinds::EOrder::Early + 1,
    []
{
    FBindFlags Flags;
    Flags.bPOD = false;
    
    auto ThisBind = FAngelscriptBinds::ValueClass<FObjectKey>("FObjectKey", Flags);
    
    auto Type = MakeShared<FAngelscriptType_FObjectKey>();
    FAngelscriptType::Register(Type);
});

// 3. 成员绑定
AS_FORCE_LINK FAngelscriptBinds::FBind Bind_FObjectKey(
    (int32)FAngelscriptBinds::EOrder::Late + 100,
    []
{
    auto ThisBind = FAngelscriptBinds::ExistingClass("FObjectKey");
    
    // 默认构造
    ThisBind.Constructor("void f()", [](FObjectKey* Address)
    {
        new(Address) FObjectKey();
    });
    SCRIPT_TRIVIAL_NATIVE_CONSTRUCTOR(ThisBind, "FObjectKey");
    
    // 从 UObject 构造
    ThisBind.Constructor("void f(const UObject Object)", 
        [](FObjectKey* Address, const UObject* Object)
    {
        new(Address) FObjectKey(Object);
    });
    
    // 运算符
    ThisBind.Method("bool opEquals(const FObjectKey& Other) const",
        [](const FObjectKey& Self, const FObjectKey& Other) -> bool
    {
        return Self == Other;
    });
    
    ThisBind.Method("int opCmp(const FObjectKey& Other) const",
        [](const FObjectKey& Self, const FObjectKey& Other) -> int
    {
        if (Self < Other) return -1;
        if (Other < Self) return 1;
        return 0;
    });
    
    // 方法
    ThisBind.Method("UObject ResolveObjectPtr() const", 
        METHOD_TRIVIAL(FObjectKey, ResolveObjectPtr));
});
```

## 案例 2：使用 Mixin 扩展现有类型

```cpp
// Mixin 类定义 - 为已绑定类型添加方法
UCLASS(Meta = (ScriptMixin = "FUIExtensionHandle"))
class UUIExtensionHandle_MixinLibrary : public UObject
{
    GENERATED_BODY()
    
public:
    // 运算符也可以通过 Mixin 添加
    UFUNCTION(ScriptCallable)
    static bool opEquals(const FUIExtensionHandle& Self, 
                         const FUIExtensionHandle& Other)
    {
        return Self == Other;
    }
    
    UFUNCTION(ScriptCallable)
    static bool opNotEquals(const FUIExtensionHandle& Self, 
                            const FUIExtensionHandle& Other)
    {
        return Self != Other;
    }
    
    // 普通方法
    UFUNCTION(ScriptCallable)
    static bool IsValid(const FUIExtensionHandle& Self)
    {
        return Self.IsValid();
    }
};
```

## 案例 3：GAS 技能系统与 AngelScript 集成（详解）

这是 DJ01 项目中遇到的核心问题和完整解决方案。

### 问题描述

AngelScript 编写的 Gameplay Ability 在调用 `TryActivateAbility` 后返回成功，但 `ActivateAbility` 事件从未触发。

### 根本原因

GAS 引擎中 `UGameplayAbility` 基类使用一组 `bHasBlueprint*` 标志位来决定是否调用脚本/蓝图端的事件函数。对于 Blueprint 子类，引擎会自动检测并设置这些标志，但 AngelScript 生成的 `UASClass` 不被识别。

---

### 核心机制：GAS 的事件分发流程

```
┌──────────────────────────────────────────────────────────────────┐
│                    GAS 激活流程示意                               │
├──────────────────────────────────────────────────────────────────┤
│  TryActivateAbility()                                            │
│       ↓                                                          │
│  ActivateAbility() [C++ 虚函数]                                  │
│       ↓                                                          │
│  检查 bHasBlueprintActivate                                      │
│       ├─ true  → 调用 K2_ActivateAbility() [脚本/蓝图事件]       │
│       └─ false → 不调用脚本事件，只执行 C++ 逻辑                  │
└──────────────────────────────────────────────────────────────────┘
```

关键标志位及对应的脚本事件：

| 标志位 | 对应脚本事件 | 作用 |
|--------|--------------|------|
| `bHasBlueprintActivate` | `K2_ActivateAbility` | 技能激活时调用 |
| `bHasBlueprintActivateFromEvent` | `K2_ActivateAbilityFromEvent` | 通过事件触发激活 |
| `bHasBlueprintCanUse` | `K2_CanActivateAbility` | 检查能否激活 |
| `bHasBlueprintShouldAbilityRespondToEvent` | `K2_ShouldAbilityRespondToEvent` | 是否响应事件 |

---

### 解决方案：C++ 基类修改详解

#### 完整代码

```cpp
// DJ01GameplayAbility.cpp
#include "ClassGenerator/ASClass.h"  // AngelScript 的类生成器头文件

UDJ01GameplayAbility::UDJ01GameplayAbility(const FObjectInitializer& ObjectInitializer)
    : Super(ObjectInitializer)
{
    // ... 其他初始化配置 ...
    
    // ═══════════════════════════════════════════════════════════════
    // AngelScript 集成：检测 AS 类是否覆盖了 K2_ 开头的蓝图事件
    // ═══════════════════════════════════════════════════════════════
    
    auto ImplementedInAS = [](const UFunction* Func) -> bool {
        return Func && 
               ensure(Func->GetOuter()) && 
               Func->GetOuter()->IsA(UASClass::StaticClass());
    };
    
    // 检测 K2_ShouldAbilityRespondToEvent
    if (!bHasBlueprintShouldAbilityRespondToEvent)
    {       
        static FName FuncName = FName(TEXT("K2_ShouldAbilityRespondToEvent"));
        UFunction* ShouldRespondFunction = GetClass()->FindFunctionByName(FuncName);
        bHasBlueprintShouldAbilityRespondToEvent = ImplementedInAS(ShouldRespondFunction);
    }
    
    // 检测 K2_CanActivateAbility
    if (!bHasBlueprintCanUse)
    {
        static FName FuncName = FName(TEXT("K2_CanActivateAbility"));
        UFunction* CanActivateFunction = GetClass()->FindFunctionByName(FuncName);
        bHasBlueprintCanUse = ImplementedInAS(CanActivateFunction);
    }
    
    // 检测 K2_ActivateAbility
    if (!bHasBlueprintActivate)
    {
        static FName FuncName = FName(TEXT("K2_ActivateAbility"));
        UFunction* ActivateFunction = GetClass()->FindFunctionByName(FuncName);
        if (ActivateFunction && (HasAnyFlags(RF_ClassDefaultObject) || ActivateFunction->IsValidLowLevelFast()))
        {
            bHasBlueprintActivate = ImplementedInAS(ActivateFunction);
        }
    }
    
    // 检测 K2_ActivateAbilityFromEvent
    if (!bHasBlueprintActivateFromEvent)
    {
        static FName FuncName = FName(TEXT("K2_ActivateAbilityFromEvent"));
        UFunction* ActivateFunction = GetClass()->FindFunctionByName(FuncName);
        bHasBlueprintActivateFromEvent = ImplementedInAS(ActivateFunction);
    }
}
```

---

#### 逐行详解

##### 1. 引入 AngelScript 类头文件

```cpp
#include "ClassGenerator/ASClass.h"
```

`UASClass` 是 AngelScript 插件定义的特殊 `UClass` 子类。当你用 AngelScript 编写一个类如 `class UGA_CastStone : UDJ01GameplayAbility` 时，插件会动态生成一个 `UASClass` 实例来代表这个脚本类。

##### 2. 检测函数的 Lambda 定义

```cpp
auto ImplementedInAS = [](const UFunction* Func) -> bool {
    return Func && 
           ensure(Func->GetOuter()) && 
           Func->GetOuter()->IsA(UASClass::StaticClass());
};
```

**工作原理：**

```
┌─────────────────────────────────────────────────────────────┐
│  UFunction 的 Outer 关系                                     │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  UASClass (AngelScript 生成的类)                            │
│      │                                                       │
│      ├── UFunction: K2_ActivateAbility    ← Outer 指向类    │
│      ├── UFunction: K2_CanActivateAbility                   │
│      └── UFunction: ...                                      │
│                                                              │
│  UBlueprintGeneratedClass (蓝图生成的类)                     │
│      │                                                       │
│      └── UFunction: K2_ActivateAbility    ← Outer 指向类    │
│                                                              │
│  普通 C++ 类 (如 UDJ01GameplayAbility)                       │
│      │                                                       │
│      └── UFunction: SomeNativeFunc        ← Outer 指向类    │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

- `Func->GetOuter()` 返回函数所属的类（`UClass*`）
- 如果这个类是 `UASClass` 类型，说明函数是在 AngelScript 中定义的
- `ensure()` 是断言宏，确保 Outer 不为空

##### 3. 条件检查：为什么先检查 `!bHasBlueprintActivate`

```cpp
if (!bHasBlueprintActivate)
{
    // ... 检测逻辑
}
```

这个条件确保：
- 如果父类（如真正的蓝图子类）已经设置了此标志，就不再重复检测
- 只有当标志未被设置时才进行 AS 检测

##### 4. 查找函数

```cpp
static FName FuncName = FName(TEXT("K2_ActivateAbility"));
UFunction* ActivateFunction = GetClass()->FindFunctionByName(FuncName);
```

- `static FName` 避免每次构造都创建 FName（性能优化）
- `GetClass()` 返回当前对象的实际类（可能是 AS 子类）
- `FindFunctionByName` 在类的函数表中查找指定名称的函数

##### 5. 安全检查

```cpp
if (ActivateFunction && (HasAnyFlags(RF_ClassDefaultObject) || ActivateFunction->IsValidLowLevelFast()))
{
    bHasBlueprintActivate = ImplementedInAS(ActivateFunction);
}
```

**为什么需要这个检查？**

```
┌─────────────────────────────────────────────────────────────┐
│  UObject 实例化时机                                          │
├─────────────────────────────────────────────────────────────┤
│                                                              │
│  1. CDO (Class Default Object) 创建                         │
│     - RF_ClassDefaultObject 标志为 true                     │
│     - 类刚注册完成，函数表可能还在构建中                      │
│     - 此时访问函数需要额外小心                               │
│                                                              │
│  2. 普通实例创建                                             │
│     - RF_ClassDefaultObject 标志为 false                    │
│     - 类已完全初始化                                         │
│     - IsValidLowLevelFast() 检查函数指针有效性               │
│                                                              │
└─────────────────────────────────────────────────────────────┘
```

- `HasAnyFlags(RF_ClassDefaultObject)`：检查当前是否是 CDO
- `IsValidLowLevelFast()`：快速检查指针是否有效（非 CDO 时使用）
- 这个双重检查来自引擎中 `UAngelscriptGASAbility` 的实现，确保在各种时机都能安全访问

---

### 整体流程图

```
┌──────────────────────────────────────────────────────────────────────────┐
│                        AngelScript GAS 集成流程                           │
└──────────────────────────────────────────────────────────────────────────┘

      AngelScript 文件                    C++ 基类构造函数
      ┌──────────────┐                   ┌──────────────────┐
      │ class UGA_X  │                   │ UDJ01Gameplay-   │
      │   : UDJ01... │                   │ Ability()        │
      │              │                   │                  │
      │ void Activate│                   │ // 检测 AS 覆盖  │
      │   Ability()  │                   │ ImplementedInAS  │
      └──────┬───────┘                   └────────┬─────────┘
             │                                    │
             ▼                                    ▼
      ┌──────────────┐                   ┌──────────────────┐
      │  AngelScript │                   │ GetClass()->     │
      │  编译器      │                   │ FindFunctionBy   │
      │              │                   │ Name("K2_...")   │
      └──────┬───────┘                   └────────┬─────────┘
             │                                    │
             ▼                                    ▼
      ┌──────────────┐                   ┌──────────────────┐
      │  UASClass    │◄──────────────────│ Func->GetOuter() │
      │  实例        │   Outer 指向      │ ->IsA(UASClass)  │
      │              │                   │                  │
      │ + UFunction  │                   │ 返回 true        │
      │   K2_Activate│                   └────────┬─────────┘
      └──────────────┘                            │
                                                  ▼
                                         ┌──────────────────┐
                                         │ bHasBlueprint-   │
                                         │ Activate = true  │
                                         └────────┬─────────┘
                                                  │
                                                  ▼
                                         ┌──────────────────┐
                                         │ GAS 激活时正确   │
                                         │ 调用脚本事件     │
                                         └──────────────────┘
```

---

### 构建依赖

在 `DJ01.Build.cs` 中添加：

```csharp
PrivateDependencyModuleNames.AddRange(new string[]
{
    "AngelscriptCode",  // 需要访问 UASClass
    // ... 其他依赖
});
```

---

### 关键点总结

| 概念 | 说明 |
|------|------|
| **CDO** | Class Default Object，UE 为每个 UClass 创建的模板实例 |
| **UASClass** | AngelScript 插件生成的特殊 UClass 子类，代表脚本定义的类 |
| **UFunction::GetOuter()** | 返回函数所属的类，用于判断函数定义在哪里 |
| **检测时机** | 在构造函数中，确保 CDO 创建时就设置好标志位 |
| **K2_ 前缀** | Kismet 2 的缩写，表示可被脚本/蓝图覆盖的事件函数 |

### 适用场景

这种模式可以应用于任何需要检测 AngelScript 覆盖蓝图事件的 C++ 基类，例如：
- `UGameplayAbility` 的子类
- `UUserWidget` 的子类
- `UActorComponent` 的子类
- 任何定义了 `BlueprintImplementableEvent` 的类

---

**上一章**: [09_内存模型.md](./09_内存模型.md)  
**下一章**: [11_附录.md](./11_附录.md) - 源码导航和调试技巧