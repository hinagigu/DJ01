#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
BindingSet 代码生成器
支持 Tag 绑定和 Attribute 绑定的 C++ 宏生成
"""

from typing import List, Set
from .data import BindingSetData, TagBinding, AttributeBinding


class BindingSetGenerator:
    """BindingSet C++ 代码生成器"""
    
    @staticmethod
    def generate_header(bindingset: BindingSetData, timestamp: str) -> str:
        """生成单个 BindingSet 的头文件"""
        macro_prefix = bindingset.macro_prefix
        
        lines = [
            f"// Auto-generated by DJ01 BindingSet Generator",
            f"// Generated at: {timestamp}",
            f"// BindingSet: {bindingset.name}",
            f"// Description: {bindingset.description}",
            f"//",
            f"// Tag Bindings: {len(bindingset.tag_bindings)}",
            f"// Attribute Bindings: {len(bindingset.attribute_bindings)}",
            f"//",
            f"// DO NOT MODIFY THIS FILE MANUALLY!",
            f"",
            f"#pragma once",
            f"",
        ]
        
        # 收集需要的 include
        includes = set()
        includes.add('"AbilitySystemComponent.h"')
        
        if bindingset.has_tag_bindings:
            includes.add('"DJ01/System/Public/DJ01GameplayTags.h"')
        
        if bindingset.has_attribute_bindings:
            # 收集所有用到的 AttributeSet
            attr_sets = set(b.attribute_set for b in bindingset.attribute_bindings)
            for attr_set in attr_sets:
                # 使用正确的模块路径
                includes.add(f'"DJ01/AbilitySystem/Attributes/Public/{attr_set}.h"')
        
        for inc in sorted(includes):
            lines.append(f"#include {inc}")
        
        lines.append("")
        
        # ============================================================
        # 变量声明宏
        # ============================================================
        lines.append(f"// ============================================================")
        lines.append(f"// 变量声明宏 - 放在类定义中 (AnimInstance, Widget, etc.)")
        lines.append(f"// ============================================================")
        lines.append(f"#define DJ01_BINDING_SET_{macro_prefix}_VARS() \\")
        
        all_vars = []
        
        # Tag 变量
        for binding in bindingset.tag_bindings:
            var_type = binding.var_type
            default_val = "false" if var_type == "bool" else "0"
            all_vars.append((var_type, binding.variable_name, default_val, f"Bindings|Tags|{bindingset.name}"))
        
        # Attribute 变量
        for binding in bindingset.attribute_bindings:
            default_val = "0.0f" if binding.var_type == "float" else "0"
            all_vars.append((binding.var_type, binding.variable_name, default_val, f"Bindings|Attributes|{bindingset.name}"))
        
        for i, (var_type, var_name, default_val, category) in enumerate(all_vars):
            line = f"\tUPROPERTY(BlueprintReadOnly, Category = \"{category}\") \\"
            lines.append(line)
            line = f"\t{var_type} {var_name} = {default_val};"
            if i < len(all_vars) - 1:
                line += " \\"
            lines.append(line)
        
        if not all_vars:
            lines[-1] = lines[-1].rstrip(" \\")  # 移除末尾的续行符
        
        lines.append("")
        
        # ============================================================
        # 回调函数宏（内部使用）
        # ============================================================
        lines.append(f"// ============================================================")
        lines.append(f"// 回调函数宏 - 内部使用")
        lines.append(f"// ============================================================")
        lines.append(f"#define DJ01_BINDING_SET_{macro_prefix}_CALLBACKS() \\")
        
        all_callbacks = []
        
        # Tag 回调
        for binding in bindingset.tag_bindings:
            if binding.event_type == "NewOrRemoved":
                body = f"{binding.variable_name} = (NewCount > 0);"
            else:
                body = f"{binding.variable_name} = NewCount;"
            all_callbacks.append(f"\tvoid {binding.callback_name}(const FGameplayTag Tag, int32 NewCount) {{ {body} }}")
        
        # Attribute 回调
        from .data import VALUE_TYPE_CURRENT, VALUE_TYPE_BASE, VALUE_TYPE_FLAT, VALUE_TYPE_PERCENT, VALUE_TYPE_TOTAL, VALUE_TYPE_EXTRA, VALUE_TYPE_MAX
        
        for binding in bindingset.attribute_bindings:
            vt = binding.value_type
            attr_set = binding.attribute_set
            attr_name = binding.attribute_name
            var_name = binding.variable_name
            
            # 计算型值（Total/Extra/Max）需要从 ASC 重新获取
            if vt == VALUE_TYPE_TOTAL:
                # Total = GetTotalXxx()，但回调时 ASC 可能还未更新，需要手动计算
                getter_call = f"Cast<U{attr_set}>(Data.Attribute.GetAttributeSetChecked())->GetTotal{attr_name}()"
                if binding.var_type == "int32":
                    body = f"{var_name} = FMath::RoundToInt({getter_call});"
                else:
                    body = f"{var_name} = {getter_call};"
            elif vt == VALUE_TYPE_EXTRA:
                getter_call = f"Cast<U{attr_set}>(Data.Attribute.GetAttributeSetChecked())->GetExtra{attr_name}()"
                if binding.var_type == "int32":
                    body = f"{var_name} = FMath::RoundToInt({getter_call});"
                else:
                    body = f"{var_name} = {getter_call};"
            elif vt == VALUE_TYPE_MAX:
                getter_call = f"Cast<U{attr_set}>(Data.Attribute.GetAttributeSetChecked())->GetTotalMax{attr_name}()"
                if binding.var_type == "int32":
                    body = f"{var_name} = FMath::RoundToInt({getter_call});"
                else:
                    body = f"{var_name} = {getter_call};"
            else:
                # 直接值（Current/Base/Flat/Percent）
                if binding.var_type == "float":
                    body = f"{var_name} = Data.NewValue.GetCurrentValue();"
                elif binding.var_type == "int32":
                    body = f"{var_name} = FMath::RoundToInt(Data.NewValue.GetCurrentValue());"
                else:
                    body = f"{var_name} = Data.NewValue;"
            
            all_callbacks.append(f"\tvoid {binding.callback_name}(const FOnAttributeChangeData& Data) {{ {body} }}")
        
        for i, callback in enumerate(all_callbacks):
            line = callback
            if i < len(all_callbacks) - 1:
                line += " \\"
            lines.append(line)
        
        if not all_callbacks:
            lines[-1] = lines[-1].rstrip(" \\")
        
        lines.append("")
        
        # ============================================================
        # 注册监听宏
        # ============================================================
        lines.append(f"// ============================================================")
        lines.append(f"// 注册监听宏 - 在获得 ASC 引用后调用")
        lines.append(f"// ============================================================")
        lines.append(f"#define DJ01_BINDING_SET_{macro_prefix}_REGISTER(InASC) \\")
        
        all_registers = []
        
        # Tag 注册
        for binding in bindingset.tag_bindings:
            event_type = f"EGameplayTagEventType::{binding.event_type}"
            all_registers.append(
                f"\tInASC->RegisterGameplayTagEvent(DJ01GameplayTags::{binding.tag_cpp_name}, {event_type})"
                f".AddUObject(this, &ThisClass::{binding.callback_name});"
            )
        
        # Attribute 注册
        from .data import VALUE_TYPE_TOTAL, VALUE_TYPE_EXTRA, VALUE_TYPE_MAX
        
        for binding in bindingset.attribute_bindings:
            vt = binding.value_type
            attr_set = binding.attribute_set
            attr_name = binding.attribute_name
            callback = binding.callback_name
            
            if vt in [VALUE_TYPE_TOTAL, VALUE_TYPE_EXTRA]:
                # 计算型值需要监听三层属性
                for prefix in ["Base", "Flat", "Percent"]:
                    getter = f"U{attr_set}::Get{prefix}{attr_name}Attribute"
                    all_registers.append(
                        f"\tInASC->GetGameplayAttributeValueChangeDelegate({getter}())"
                        f".AddUObject(this, &ThisClass::{callback});"
                    )
            elif vt == VALUE_TYPE_MAX:
                # Max 资源型需要监听三层 Max 属性
                for prefix in ["Base", "Flat", "Percent"]:
                    getter = f"U{attr_set}::Get{prefix}Max{attr_name}Attribute"
                    all_registers.append(
                        f"\tInASC->GetGameplayAttributeValueChangeDelegate({getter}())"
                        f".AddUObject(this, &ThisClass::{callback});"
                    )
            else:
                # 直接属性监听
                all_registers.append(
                    f"\tInASC->GetGameplayAttributeValueChangeDelegate({binding.attribute_getter_name}())"
                    f".AddUObject(this, &ThisClass::{callback});"
                )
        
        for i, reg in enumerate(all_registers):
            line = reg
            if i < len(all_registers) - 1:
                line += " \\"
            lines.append(line)
        
        if not all_registers:
            lines[-1] = lines[-1].rstrip(" \\")
        
        lines.append("")
        
        # ============================================================
        # 解除注册宏
        # ============================================================
        lines.append(f"// ============================================================")
        lines.append(f"// 解除注册宏 - 在清理时调用")
        lines.append(f"// ============================================================")
        lines.append(f"#define DJ01_BINDING_SET_{macro_prefix}_UNREGISTER(InASC) \\")
        lines.append(f"\tif (InASC) {{ \\")
        
        all_unregisters = []
        
        # Tag 解除注册
        for binding in bindingset.tag_bindings:
            all_unregisters.append(
                f"\t\tInASC->RegisterGameplayTagEvent(DJ01GameplayTags::{binding.tag_cpp_name}, "
                f"EGameplayTagEventType::NewOrRemoved).RemoveAll(this);"
            )
        
        # Attribute 解除注册
        for binding in bindingset.attribute_bindings:
            vt = binding.value_type
            attr_set = binding.attribute_set
            attr_name = binding.attribute_name
            
            if vt in [VALUE_TYPE_TOTAL, VALUE_TYPE_EXTRA]:
                # 计算型值需要解除三层属性的监听
                for prefix in ["Base", "Flat", "Percent"]:
                    getter = f"U{attr_set}::Get{prefix}{attr_name}Attribute"
                    all_unregisters.append(
                        f"\t\tInASC->GetGameplayAttributeValueChangeDelegate({getter}())"
                        f".RemoveAll(this);"
                    )
            elif vt == VALUE_TYPE_MAX:
                # Max 资源型需要解除三层 Max 属性的监听
                for prefix in ["Base", "Flat", "Percent"]:
                    getter = f"U{attr_set}::Get{prefix}Max{attr_name}Attribute"
                    all_unregisters.append(
                        f"\t\tInASC->GetGameplayAttributeValueChangeDelegate({getter}())"
                        f".RemoveAll(this);"
                    )
            else:
                # 直接属性解除监听
                all_unregisters.append(
                    f"\t\tInASC->GetGameplayAttributeValueChangeDelegate({binding.attribute_getter_name}())"
                    f".RemoveAll(this);"
                )
        
        for i, unreg in enumerate(all_unregisters):
            line = unreg
            if i < len(all_unregisters) - 1:
                line += " \\"
            else:
                line += " \\"
            lines.append(line)
        
        lines.append(f"\t}}")
        lines.append("")
        
        # ============================================================
        # 初始化值宏（内部使用）
        # ============================================================
        lines.append(f"// ============================================================")
        lines.append(f"// 初始化值宏 - 内部使用")
        lines.append(f"// ============================================================")
        lines.append(f"#define DJ01_BINDING_SET_{macro_prefix}_INIT_VALUES(ASC) \\")
        
        init_lines = []
        
        # Attribute 初始化
        for binding in bindingset.attribute_bindings:
            vt = binding.value_type
            attr_set = binding.attribute_set
            attr_name = binding.attribute_name
            var_name = binding.variable_name
            var_type = binding.var_type
            
            # 根据 value_type 生成正确的初始化代码
            if vt == VALUE_TYPE_TOTAL:
                getter_call = f"Cast<U{attr_set}>(InASC->GetAttributeSet(U{attr_set}::StaticClass()))->GetTotal{attr_name}()"
            elif vt == VALUE_TYPE_EXTRA:
                getter_call = f"Cast<U{attr_set}>(InASC->GetAttributeSet(U{attr_set}::StaticClass()))->GetExtra{attr_name}()"
            elif vt == VALUE_TYPE_MAX:
                getter_call = f"Cast<U{attr_set}>(InASC->GetAttributeSet(U{attr_set}::StaticClass()))->GetTotalMax{attr_name}()"
            elif vt == VALUE_TYPE_CURRENT:
                getter_call = f"InASC->GetNumericAttribute({binding.attribute_getter_name}())"
            else:
                # Base/Flat/Percent - 直接从层属性获取
                actual_getter = f"U{attr_set}::Get{binding.actual_attribute_name}Attribute"
                getter_call = f"InASC->GetNumericAttribute({actual_getter}())"
            
            if var_type == "int32":
                init_lines.append(f"\t{var_name} = FMath::RoundToInt({getter_call});")
            else:
                init_lines.append(f"\t{var_name} = {getter_call};")
        
        # Tag 初始化（检查当前状态）
        for binding in bindingset.tag_bindings:
            if binding.event_type == "NewOrRemoved":
                init_lines.append(
                    f"\t{binding.variable_name} = InASC->HasMatchingGameplayTag(DJ01GameplayTags::{binding.tag_cpp_name});"
                )
            else:
                init_lines.append(
                    f"\t{binding.variable_name} = InASC->GetTagCount(DJ01GameplayTags::{binding.tag_cpp_name});"
                )
        
        # 如果没有任何初始化内容，添加空操作
        if not init_lines:
            init_lines.append("\t(void)InASC;")
        
        for i, init_line in enumerate(init_lines):
            line = init_line
            if i < len(init_lines) - 1:
                line += " \\"
            lines.append(line)
        
        lines.append("")
        
        # ============================================================
        # 初始化函数宏（BlueprintCallable）
        # ============================================================
        lines.append(f"// ============================================================")
        lines.append(f"// 初始化函数 - 蓝图可调用！")
        lines.append(f"// ============================================================")
        lines.append(f"#define DJ01_BINDING_SET_{macro_prefix}_INIT_FUNC() \\")
        lines.append(f"\tUFUNCTION(BlueprintCallable, Category = \"GAS|BindingSet|{bindingset.name}\") \\")
        lines.append(f"\tvoid InitBindingSet_{bindingset.name}(UAbilitySystemComponent* InASC) \\")
        lines.append(f"\t{{ \\")
        lines.append(f"\t\tif (!InASC) return; \\")
        lines.append(f"\t\tDJ01_BINDING_SET_{macro_prefix}_REGISTER(InASC) \\")
        lines.append(f"\t\tDJ01_BINDING_SET_{macro_prefix}_INIT_VALUES(InASC) \\")
        lines.append(f"\t}}")
        lines.append("")
        
        # ============================================================
        # 清理函数宏（BlueprintCallable）
        # ============================================================
        lines.append(f"// ============================================================")
        lines.append(f"// 清理函数 - 蓝图可调用！")
        lines.append(f"// ============================================================")
        lines.append(f"#define DJ01_BINDING_SET_{macro_prefix}_CLEANUP_FUNC() \\")
        lines.append(f"\tUFUNCTION(BlueprintCallable, Category = \"GAS|BindingSet|{bindingset.name}\") \\")
        lines.append(f"\tvoid CleanupBindingSet_{bindingset.name}(UAbilitySystemComponent* InASC) \\")
        lines.append(f"\t{{ \\")
        lines.append(f"\t\tDJ01_BINDING_SET_{macro_prefix}_UNREGISTER(InASC) \\")
        lines.append(f"\t}}")
        lines.append("")
        
        return '\n'.join(lines)
    
    @staticmethod
    def generate_index_header(bindingsets: List[BindingSetData], timestamp: str) -> str:
        """生成汇总头文件，包含所有 BindingSet 和简化宏"""
        lines = [
            f"// Auto-generated by DJ01 BindingSet Generator",
            f"// Generated at: {timestamp}",
            f"//",
            f"// This file includes all BindingSet headers and provides simplified macros",
            f"// DO NOT MODIFY THIS FILE MANUALLY!",
            f"",
            f"#pragma once",
            f"",
        ]
        
        # Include 所有 BindingSet 头文件
        for bs in bindingsets:
            lines.append(f"#include \"{bs.header_filename}\"")
        
        lines.append("")
        lines.append("// ============================================================")
        lines.append("// 简化宏 - 一行声明，一行初始化！")
        lines.append("// ============================================================")
        lines.append("//")
        lines.append("// 用法:")
        lines.append("//   DJ01_DECLARE_BINDING_SET(Name)     - 在类中声明变量和回调")
        lines.append("//   DJ01_INIT_BINDING_SET(Name, ASC)   - 注册监听并初始化值")
        lines.append("//   DJ01_CLEANUP_BINDING_SET(Name, ASC) - 清理监听")
        lines.append("//")
        lines.append("")
        
        # 为每个 BindingSet 生成简化宏映射
        for bs in bindingsets:
            prefix = bs.macro_prefix
            name = bs.name
            
            lines.append(f"// --- {name} ---")
            
            # DECLARE 宏：声明变量 + 回调 + 初始化函数 + 清理函数
            lines.append(f"#define DJ01_DECLARE_BINDING_SET_{name}() \\")
            lines.append(f"\tDJ01_BINDING_SET_{prefix}_VARS() \\")
            lines.append(f"\tDJ01_BINDING_SET_{prefix}_CALLBACKS() \\")
            lines.append(f"\tDJ01_BINDING_SET_{prefix}_INIT_FUNC() \\")
            lines.append(f"\tDJ01_BINDING_SET_{prefix}_CLEANUP_FUNC()")
            lines.append("")
        
        # 通用宏（使用宏拼接）
        lines.append("// ============================================================")
        lines.append("// 通用宏 - 支持任意 BindingSet 名称")
        lines.append("// ============================================================")
        lines.append("")
        lines.append("// 宏拼接辅助")
        lines.append("#define DJ01_BINDING_SET_CONCAT_IMPL(a, b) a##b")
        lines.append("#define DJ01_BINDING_SET_CONCAT(a, b) DJ01_BINDING_SET_CONCAT_IMPL(a, b)")
        lines.append("")
        lines.append("// 通用声明宏 - 声明变量、回调和初始化/清理函数")
        lines.append("#define DJ01_DECLARE_BINDING_SET(Name) \\")
        lines.append("\tDJ01_BINDING_SET_CONCAT(DJ01_DECLARE_BINDING_SET_, Name)()")
        lines.append("")
        
        # 使用示例
        lines.append("// ============================================================")
        lines.append("// 使用示例")
        lines.append("// ============================================================")
        lines.append("//")
        lines.append("// -------- AnimInstance (C++) --------")
        lines.append("// ")
        lines.append("// UCLASS()")
        lines.append("// class UMyAnimInstance : public UAnimInstance")
        lines.append("// {")
        lines.append("//     GENERATED_BODY()")
        lines.append("// public:")
        
        for bs in bindingsets:
            lines.append(f"//     DJ01_DECLARE_BINDING_SET({bs.name})")
        
        lines.append("//")
        lines.append("//     // 宏自动生成了以下蓝图可调用函数：")
        
        for bs in bindingsets:
            lines.append(f"//     // - InitBindingSet_{bs.name}(UAbilitySystemComponent* InASC)")
            lines.append(f"//     // - CleanupBindingSet_{bs.name}(UAbilitySystemComponent* InASC)")
        
        lines.append("//")
        lines.append("//     // C++ 中直接调用：")
        lines.append("//     void InitializeWithAbilitySystem(UAbilitySystemComponent* ASC)")
        lines.append("//     {")
        
        for bs in bindingsets:
            lines.append(f"//         InitBindingSet_{bs.name}(ASC);")
        
        lines.append("//     }")
        lines.append("// };")
        lines.append("//")
        lines.append("// -------- 蓝图中使用 --------")
        lines.append("//")
        lines.append("// 1. 获取 AbilitySystemComponent")
        lines.append("// 2. 调用 InitBindingSet_XXX 节点")
        lines.append("// 3. 绑定的变量会自动更新！")
        lines.append("//")
        lines.append("")
        
        # 列出所有可用的 BindingSet
        lines.append("// ============================================================")
        lines.append("// 可用的 BindingSet 列表")
        lines.append("// ============================================================")
        lines.append("//")
        
        for bs in bindingsets:
            tag_count = len(bs.tag_bindings)
            attr_count = len(bs.attribute_bindings)
            lines.append(f"// - {bs.name}: {tag_count} Tags, {attr_count} Attributes")
            
            # 列出变量名
            if bs.tag_bindings:
                tag_vars = ", ".join(b.variable_name for b in bs.tag_bindings[:5])
                if len(bs.tag_bindings) > 5:
                    tag_vars += ", ..."
                lines.append(f"//     Tags: {tag_vars}")
            
            if bs.attribute_bindings:
                attr_vars = ", ".join(b.variable_name for b in bs.attribute_bindings[:5])
                if len(bs.attribute_bindings) > 5:
                    attr_vars += ", ..."
                lines.append(f"//     Attrs: {attr_vars}")
        
        lines.append("//")
        lines.append("")
        
        return '\n'.join(lines)

