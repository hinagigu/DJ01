{
  "name": "UAnimInstance",
  "inherits": "UObject",
  "properties": {
    "OnMontageBlendingOut": [
      "FOnMontageBlendingOutStartedMCDelegate",
      "Called when a montage starts blending out, whether interrupted or finished"
    ],
    "OnMontageBlendedIn": [
      "FOnMontageBlendedInEndedMCDelegate",
      "Called when a montage finishes blending in"
    ],
    "OnMontageStarted": [
      "FOnMontageStartedMCDelegate",
      "Called when a montage has started"
    ],
    "OnMontageEnded": [
      "FOnMontageEndedMCDelegate",
      "Called when a montage has ended, whether interrupted or finished"
    ],
    "OnAllMontageInstancesEnded": [
      "FOnAllMontageInstancesEndedMCDelegate",
      "Called when all Montage instances have ended."
    ],
    "bReceiveNotifiesFromLinkedInstances": [
      "bool",
      "Whether to process notifies from any linked anim instances"
    ],
    "bPropagateNotifiesToLinkedInstances": [
      "bool",
      "Whether to propagate notifies to any linked anim instances"
    ],
    "bUseMainInstanceMontageEvaluationData": [
      "bool",
      "If true, linked instances will use the main instance's montage data. (i.e. playing a montage on a main instance will play it on the linked layer too.)"
    ]
  },
  "methods": [
    {
      "name": "Blueprint_GetMainAnimInstance",
      "return": "UAnimInstance",
      "const": true,
      "doc": "Get the 'main' anim instance, i.e. the one that is hosted on the skeletal mesh component",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "Blueprint_GetSlotMontageLocalWeight",
      "return": "float32",
      "const": true,
      "doc": "Get local weight of any montages this slot node is playing. If this slot is not currently playing a montage, it will return 0.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "SlotNodeName",
          "type": "FName"
        }
      ]
    },
    {
      "name": "BlueprintBeginPlay",
      "return": "void",
      "callable": false,
      "doc": "Executed when begin play is called on the owning component",
      "event": true,
      "meta": null,
      "args": []
    },
    {
      "name": "BlueprintInitializeAnimation",
      "return": "void",
      "callable": false,
      "doc": "Executed when the Animation is initialized",
      "event": true,
      "meta": null,
      "args": []
    },
    {
      "name": "BlueprintLinkedAnimationLayersInitialized",
      "return": "void",
      "callable": false,
      "doc": "Executed when the all Linked Animation Layers are initialized",
      "event": true,
      "meta": null,
      "args": []
    },
    {
      "name": "BlueprintPostEvaluateAnimation",
      "return": "void",
      "callable": false,
      "doc": "Executed after the Animation is evaluated",
      "event": true,
      "meta": null,
      "args": []
    },
    {
      "name": "BlueprintThreadSafeUpdateAnimation",
      "return": "void",
      "callable": false,
      "doc": "Executed when the Animation Blueprint is updated on a worker thread, just prior to graph update",
      "event": true,
      "meta": null,
      "args": [
        {
          "name": "DeltaTime",
          "type": "float"
        }
      ]
    },
    {
      "name": "BlueprintUpdateAnimation",
      "return": "void",
      "callable": false,
      "doc": "Executed when the Animation is updated",
      "event": true,
      "meta": null,
      "args": [
        {
          "name": "DeltaTimeX",
          "type": "float"
        }
      ]
    },
    {
      "name": "CalculateDirection",
      "return": "float32",
      "const": true,
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Velocity",
          "type": "FVector"
        },
        {
          "name": "BaseRotation",
          "type": "FRotator"
        }
      ]
    },
    {
      "name": "ClearAllTransitionEvents",
      "return": "void",
      "doc": "Removes all queued transition requests",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "ClearMorphTargets",
      "return": "void",
      "doc": "Clears the current morph targets.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "ClearTransitionEvents",
      "return": "void",
      "doc": "Removes all queued transition requests with the given event name",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "EventName",
          "type": "FName"
        }
      ]
    },
    {
      "name": "DynamicMontage_IsPlayingFrom",
      "return": "bool",
      "const": true,
      "doc": "Returns true if there is an animation montage is currently active and playing that was created from the provided animation.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Animation",
          "type": "const UAnimSequenceBase"
        }
      ]
    },
    {
      "name": "GetActiveCurveNames",
      "return": "void",
      "const": true,
      "doc": "This returns last up-to-date list of active curve names",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "CurveType",
          "type": "EAnimCurveType"
        },
        {
          "name": "OutNames",
          "type": "TArray<FName>&"
        }
      ]
    },
    {
      "name": "GetAllCurveNames",
      "return": "void",
      "const": true,
      "doc": "This returns all curve names. This is the same as calling GetActiveCurveNames with CurveType == AttributeCurve",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "OutNames",
          "type": "TArray<FName>&"
        }
      ]
    },
    {
      "name": "GetCurrentActiveMontage",
      "return": "UAnimMontage",
      "const": true,
      "doc": "Get a current Active Montage in this AnimInstance.\n              Note that there might be multiple Active at the same time. This will only return the first active one it finds. *",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetCurveValue",
      "return": "float32",
      "const": true,
      "doc": "Returns the value of a named curve.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "CurveName",
          "type": "FName"
        }
      ]
    },
    {
      "name": "GetCurveValueWithDefault",
      "return": "bool",
      "doc": "Returns whether a named curve was found, its value, and a default value when it's not found.\n@param        AnimInstance    The anim instance to find this curve value for.\n@param        CurveName               The name of the curve.\n@param        DefaultValue    Value to use when the curve is not found.\n@param        OutValue                The curve's value.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "CurveName",
          "type": "FName"
        },
        {
          "name": "DefaultValue",
          "type": "float32"
        },
        {
          "name": "OutValue",
          "type": "float32&"
        }
      ]
    },
    {
      "name": "GetDeltaSeconds",
      "return": "float32",
      "const": true,
      "doc": "Get the current delta time",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetLinkedAnimGraphInstanceByTag",
      "return": "UAnimInstance",
      "const": true,
      "doc": "Runs through all nodes, attempting to find the first linked instance by name/tag",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "InTag",
          "type": "FName"
        }
      ]
    },
    {
      "name": "GetLinkedAnimLayerInstanceByClass",
      "return": "UAnimInstance",
      "const": true,
      "doc": "Gets the first layer linked instance corresponding to the specified class, optionally if bCheckForChildClass is true, it will check IsChildOf on InClass.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "InClass",
          "type": "TSubclassOf<UAnimInstance>"
        },
        {
          "name": "bCheckForChildClass",
          "default": "false",
          "type": "bool"
        }
      ]
    },
    {
      "name": "GetLinkedAnimLayerInstanceByGroup",
      "return": "UAnimInstance",
      "const": true,
      "doc": "Gets the layer linked instance corresponding to the specified group",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "InGroup",
          "type": "FName"
        }
      ]
    },
    {
      "name": "GetLinkedAnimLayerInstanceByGroupAndClass",
      "return": "UAnimInstance",
      "const": true,
      "doc": "Gets layer linked instance that matches group and class",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "InGroup",
          "type": "FName"
        },
        {
          "name": "InClass",
          "type": "TSubclassOf<UAnimInstance>"
        }
      ]
    },
    {
      "name": "GetLinkedAnimLayerInstancesByGroup",
      "return": "void",
      "const": true,
      "doc": "Runs through all nodes, attempting to find all distinct layer linked instances in the group",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "InGroup",
          "type": "FName"
        },
        {
          "name": "OutLinkedInstances",
          "type": "TArray<UAnimInstance>&"
        }
      ]
    },
    {
      "name": "GetOwningActor",
      "return": "AActor",
      "const": true,
      "doc": "Returns the owning actor of this AnimInstance",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetOwningComponent",
      "return": "USkeletalMeshComponent",
      "const": true,
      "doc": "Returns the skeletal mesh component that has created this AnimInstance",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetPropagateNotifiesToLinkedInstances",
      "return": "bool",
      "const": true,
      "doc": "Get whether to propagate notifies to any linked anim instances",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetReceiveNotifiesFromLinkedInstances",
      "return": "bool",
      "const": true,
      "doc": "Get whether to process notifies from any linked anim instances",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetSyncGroupPosition",
      "return": "FMarkerSyncAnimPosition",
      "const": true,
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "InSyncGroupName",
          "type": "FName"
        }
      ]
    },
    {
      "name": "GetTimeToClosestMarker",
      "return": "bool",
      "const": true,
      "doc": "--- AI communication end ---",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "SyncGroup",
          "type": "FName"
        },
        {
          "name": "MarkerName",
          "type": "FName"
        },
        {
          "name": "OutMarkerTime",
          "type": "float32&"
        }
      ]
    },
    {
      "name": "HasMarkerBeenHitThisFrame",
      "return": "bool",
      "const": true,
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "SyncGroup",
          "type": "FName"
        },
        {
          "name": "MarkerName",
          "type": "FName"
        }
      ]
    },
    {
      "name": "IsAnyMontagePlaying",
      "return": "bool",
      "const": true,
      "doc": "Returns true if any montage is playing currently. Doesn't mean it's active though, it could be blending out.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "IsPlayingSlotAnimation",
      "return": "bool",
      "const": true,
      "doc": "Return true if it's playing the slot animation",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Asset",
          "type": "const UAnimSequenceBase"
        },
        {
          "name": "SlotNodeName",
          "type": "FName"
        }
      ]
    },
    {
      "name": "IsSlotActive",
      "return": "bool",
      "const": true,
      "doc": "Return true if this instance has an active montage in the given slot. A UAnimMontage that is playing in the slot and blending out is not determined to be \"active\".",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "SlotNodeName",
          "type": "FName"
        }
      ]
    },
    {
      "name": "IsSyncGroupBetweenMarkers",
      "return": "bool",
      "const": true,
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "InSyncGroupName",
          "type": "FName"
        },
        {
          "name": "PreviousMarker",
          "type": "FName"
        },
        {
          "name": "NextMarker",
          "type": "FName"
        },
        {
          "name": "bRespectMarkerOrder",
          "default": "true",
          "type": "bool"
        }
      ]
    },
    {
      "name": "IsUsingMainInstanceMontageEvaluationData",
      "return": "bool",
      "const": true,
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "LinkAnimClassLayers",
      "return": "void",
      "doc": "Runs through all layer nodes, attempting to find layer nodes that are implemented by the specified class, then sets up a linked instance of the class for each.\nAllocates one linked instance to run each of the groups specified in the class, so state is shared. If a layer is not grouped (ie. NAME_None), then state is not shared\nand a separate linked instance is allocated for each layer node.\nIf InClass is null, then all layers are reset to their defaults.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "InClass",
          "type": "TSubclassOf<UAnimInstance>"
        }
      ]
    },
    {
      "name": "LinkAnimGraphByTag",
      "return": "void",
      "doc": "Runs through all nodes, attempting to find a linked instance by name/tag, then sets the class of each node if the tag matches",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "InTag",
          "type": "FName"
        },
        {
          "name": "InClass",
          "type": "TSubclassOf<UAnimInstance>"
        }
      ]
    },
    {
      "name": "Montage_GetBlendTime",
      "return": "float32",
      "const": true,
      "doc": "Get the current blend time of the Montage.\n      If Montage reference is NULL, it will return the current blend time on the first active Montage found.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Montage",
          "type": "const UAnimMontage"
        }
      ]
    },
    {
      "name": "Montage_GetCurrentSection",
      "return": "FName",
      "const": true,
      "doc": "Returns the name of the current animation montage section.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Montage",
          "default": "nullptr",
          "type": "const UAnimMontage"
        }
      ]
    },
    {
      "name": "Montage_GetEffectivePlayRate",
      "return": "float32",
      "const": true,
      "doc": "Get scaled PlayRate for Montage. This accounts for RateScale, so it will reflect the actual play rate seen in game.\n      If Montage reference is NULL, scaled PlayRate for any Active Montage will be returned.\n      If Montage is not playing, 0 is returned.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Montage",
          "type": "const UAnimMontage"
        }
      ]
    },
    {
      "name": "Montage_GetIsStopped",
      "return": "bool",
      "const": true,
      "doc": "return true if Montage is not currently active. (not valid or blending out)",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Montage",
          "type": "const UAnimMontage"
        }
      ]
    },
    {
      "name": "Montage_GetPlayRate",
      "return": "float32",
      "const": true,
      "doc": "Get PlayRate for Montage. This does not account for RateScale, so it may not reflect the actual play rate seen in game (see Montage_GetEffectivePlayRate).\n      If Montage reference is NULL, PlayRate for any Active Montage will be returned.\n      If Montage is not playing, 0 is returned.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Montage",
          "type": "const UAnimMontage"
        }
      ]
    },
    {
      "name": "Montage_GetPosition",
      "return": "float32",
      "const": true,
      "doc": "Get Current Montage Position",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Montage",
          "type": "const UAnimMontage"
        }
      ]
    },
    {
      "name": "Montage_IsActive",
      "return": "bool",
      "const": true,
      "doc": "Returns true if the animation montage is active. If the Montage reference is NULL, it will return true if any Montage is active.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Montage",
          "type": "const UAnimMontage"
        }
      ]
    },
    {
      "name": "Montage_IsPlaying",
      "return": "bool",
      "const": true,
      "doc": "Returns true if the animation montage is currently active and playing.\n      If reference is NULL, it will return true is ANY montage is currently active and playing.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Montage",
          "type": "const UAnimMontage"
        }
      ]
    },
    {
      "name": "Montage_JumpToSection",
      "return": "void",
      "doc": "Makes a montage jump to a named section. If Montage reference is NULL, it will do that to all active montages.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "SectionName",
          "type": "FName"
        },
        {
          "name": "Montage",
          "default": "nullptr",
          "type": "const UAnimMontage"
        }
      ]
    },
    {
      "name": "Montage_JumpToSectionsEnd",
      "return": "void",
      "doc": "Makes a montage jump to the end of a named section. If Montage reference is NULL, it will do that to all active montages.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "SectionName",
          "type": "FName"
        },
        {
          "name": "Montage",
          "default": "nullptr",
          "type": "const UAnimMontage"
        }
      ]
    },
    {
      "name": "Montage_Pause",
      "return": "void",
      "doc": "Pauses the animation montage. If reference is NULL, it will pause ALL active montages.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Montage",
          "default": "nullptr",
          "type": "const UAnimMontage"
        }
      ]
    },
    {
      "name": "Montage_Play",
      "return": "float32",
      "doc": "Plays an animation montage. Returns the length of the animation montage in seconds. Returns 0.f if failed to play.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "MontageToPlay",
          "type": "UAnimMontage"
        },
        {
          "name": "InPlayRate",
          "default": "1.000000",
          "type": "float32"
        },
        {
          "name": "ReturnValueType",
          "default": "EMontagePlayReturnType :: MontageLength",
          "type": "EMontagePlayReturnType"
        },
        {
          "name": "InTimeToStartMontageAt",
          "default": "0.000000",
          "type": "float32"
        },
        {
          "name": "bStopAllMontages",
          "default": "true",
          "type": "bool"
        }
      ]
    },
    {
      "name": "Montage_PlayWithBlendIn",
      "return": "float32",
      "doc": "Plays an animation montage. Same as Montage_Play, but you can specify an AlphaBlend for Blend In settings.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "MontageToPlay",
          "type": "UAnimMontage"
        },
        {
          "name": "BlendIn",
          "type": "FAlphaBlendArgs"
        },
        {
          "name": "InPlayRate",
          "default": "1.000000",
          "type": "float32"
        },
        {
          "name": "ReturnValueType",
          "default": "EMontagePlayReturnType :: MontageLength",
          "type": "EMontagePlayReturnType"
        },
        {
          "name": "InTimeToStartMontageAt",
          "default": "0.000000",
          "type": "float32"
        },
        {
          "name": "bStopAllMontages",
          "default": "true",
          "type": "bool"
        }
      ]
    },
    {
      "name": "Montage_PlayWithBlendSettings",
      "return": "float32",
      "doc": "Plays an animation montage. Same as Montage_Play, but you can overwrite all of the montage's default blend in settings.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "MontageToPlay",
          "type": "UAnimMontage"
        },
        {
          "name": "BlendInSettings",
          "type": "FMontageBlendSettings"
        },
        {
          "name": "InPlayRate",
          "default": "1.000000",
          "type": "float32"
        },
        {
          "name": "ReturnValueType",
          "default": "EMontagePlayReturnType :: MontageLength",
          "type": "EMontagePlayReturnType"
        },
        {
          "name": "InTimeToStartMontageAt",
          "default": "0.000000",
          "type": "float32"
        },
        {
          "name": "bStopAllMontages",
          "default": "true",
          "type": "bool"
        }
      ]
    },
    {
      "name": "Montage_Resume",
      "return": "void",
      "doc": "Resumes a paused animation montage. If reference is NULL, it will resume ALL active montages.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Montage",
          "type": "const UAnimMontage"
        }
      ]
    },
    {
      "name": "Montage_SetNextSection",
      "return": "void",
      "doc": "Relink new next section AFTER SectionNameToChange in run-time\n    You can link section order the way you like in editor, but in run-time if you'd like to change it dynamically,\n    use this function to relink the next section\n    For example, you can have Start->Loop->Loop->Loop.... but when you want it to end, you can relink\n    next section of Loop to be End to finish the montage, in which case, it stops looping by Loop->End.\n\n@param SectionNameToChange : This should be the name of the Montage Section after which you want to insert a new next section\n@param NextSection   : new next section",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "SectionNameToChange",
          "type": "FName"
        },
        {
          "name": "NextSection",
          "type": "FName"
        },
        {
          "name": "Montage",
          "default": "nullptr",
          "type": "const UAnimMontage"
        }
      ]
    },
    {
      "name": "Montage_SetPlayRate",
      "return": "void",
      "doc": "Change AnimMontage play rate. NewPlayRate = 1.0 is the default playback rate.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Montage",
          "type": "const UAnimMontage"
        },
        {
          "name": "NewPlayRate",
          "default": "1.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "Montage_SetPosition",
      "return": "void",
      "doc": "Set position.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Montage",
          "type": "const UAnimMontage"
        },
        {
          "name": "NewPosition",
          "type": "float32"
        }
      ]
    },
    {
      "name": "Montage_Stop",
      "return": "void",
      "doc": "Stopped montages will blend out using their montage asset's BlendOut, with InBlendOutTime as the BlendTime",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "InBlendOutTime",
          "type": "float32"
        },
        {
          "name": "Montage",
          "default": "nullptr",
          "type": "const UAnimMontage"
        }
      ]
    },
    {
      "name": "Montage_StopGroupByName",
      "return": "void",
      "doc": "Stops all active montages belonging to a group.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "InBlendOutTime",
          "type": "float32"
        },
        {
          "name": "GroupName",
          "type": "FName"
        }
      ]
    },
    {
      "name": "Montage_StopWithBlendOut",
      "return": "void",
      "doc": "Same as Montage_Stop. Uses values from the AlphaBlendArgs. Other settings come from the montage asset",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "BlendOut",
          "type": "FAlphaBlendArgs"
        },
        {
          "name": "Montage",
          "default": "nullptr",
          "type": "const UAnimMontage"
        }
      ]
    },
    {
      "name": "Montage_StopWithBlendSettings",
      "return": "void",
      "doc": "Same as Montage_Stop, but all blend settings are provided instead of using the ones on the montage asset",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "BlendOutSettings",
          "type": "FMontageBlendSettings"
        },
        {
          "name": "Montage",
          "default": "nullptr",
          "type": "const UAnimMontage"
        }
      ]
    },
    {
      "name": "MontageSync_Follow",
      "return": "void",
      "doc": "Synchronize a montage to another anim instance's montage. Both montages must be playing already\n@param MontageFollower : The montage that will follow the leader in OtherAnimInstance\n@param OtherAnimInstance      : The other anim instance we want to synchronize to. Can be set to self\n@param MontageLeader  : The montage we want to follow in the other anim instance",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "MontageFollower",
          "type": "const UAnimMontage"
        },
        {
          "name": "OtherAnimInstance",
          "type": "const UAnimInstance"
        },
        {
          "name": "MontageLeader",
          "type": "const UAnimMontage"
        }
      ]
    },
    {
      "name": "MontageSync_StopFollowing",
      "return": "void",
      "doc": "Stop following the montage's leader in this anim instance\n@param MontageFollower : The montage we want to stop synchronizing",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "MontageFollower",
          "type": "const UAnimMontage"
        }
      ]
    },
    {
      "name": "PlaySlotAnimationAsDynamicMontage",
      "return": "UAnimMontage",
      "doc": "Play normal animation asset on the slot node by creating a dynamic UAnimMontage. You can only play one asset (whether montage or animsequence) at a time per SlotGroup.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Asset",
          "type": "UAnimSequenceBase"
        },
        {
          "name": "SlotNodeName",
          "type": "FName"
        },
        {
          "name": "BlendInTime",
          "default": "0.250000",
          "type": "float32"
        },
        {
          "name": "BlendOutTime",
          "default": "0.250000",
          "type": "float32"
        },
        {
          "name": "InPlayRate",
          "default": "1.000000",
          "type": "float32"
        },
        {
          "name": "LoopCount",
          "default": "1",
          "type": "int"
        },
        {
          "name": "BlendOutTriggerTime",
          "default": "- 1.000000",
          "type": "float32"
        },
        {
          "name": "InTimeToStartMontageAt",
          "default": "0.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "PlaySlotAnimationAsDynamicMontage_WithBlendArgs",
      "return": "UAnimMontage",
      "doc": "Play normal animation asset on the slot node by creating a dynamic UAnimMontage with blend in arguments. You can only play one asset (whether montage or animsequence) at a time per SlotGroup.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Asset",
          "type": "UAnimSequenceBase"
        },
        {
          "name": "SlotNodeName",
          "type": "FName"
        },
        {
          "name": "BlendIn",
          "type": "FAlphaBlendArgs"
        },
        {
          "name": "BlendOut",
          "type": "FAlphaBlendArgs"
        },
        {
          "name": "InPlayRate",
          "default": "1.000000",
          "type": "float32"
        },
        {
          "name": "LoopCount",
          "default": "1",
          "type": "int"
        },
        {
          "name": "BlendOutTriggerTime",
          "default": "- 1.000000",
          "type": "float32"
        },
        {
          "name": "InTimeToStartMontageAt",
          "default": "0.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "PlaySlotAnimationAsDynamicMontage_WithBlendSettings",
      "return": "UAnimMontage",
      "doc": "Play normal animation asset on the slot node by creating a dynamic UAnimMontage with blend in settings. You can only play one asset (whether montage or animsequence) at a time per SlotGroup.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Asset",
          "type": "UAnimSequenceBase"
        },
        {
          "name": "SlotNodeName",
          "type": "FName"
        },
        {
          "name": "BlendInSettings",
          "type": "FMontageBlendSettings"
        },
        {
          "name": "BlendOutSettings",
          "type": "FMontageBlendSettings"
        },
        {
          "name": "InPlayRate",
          "default": "1.000000",
          "type": "float32"
        },
        {
          "name": "LoopCount",
          "default": "1",
          "type": "int"
        },
        {
          "name": "BlendOutTriggerTime",
          "default": "- 1.000000",
          "type": "float32"
        },
        {
          "name": "InTimeToStartMontageAt",
          "default": "0.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "RemovePoseSnapshot",
      "return": "void",
      "doc": "Remove a previously saved pose snapshot from the internal snapshot cache",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "SnapshotName",
          "type": "FName"
        }
      ]
    },
    {
      "name": "RequestSlotGroupInertialization",
      "return": "void",
      "doc": "Requests an inertial blend during the next anim graph update. Requires your anim graph to have a slot node belonging to the specified group name",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "InSlotGroupName",
          "type": "FName"
        },
        {
          "name": "Duration",
          "type": "float32"
        },
        {
          "name": "BlendProfile",
          "default": "nullptr",
          "type": "const UBlendProfile"
        }
      ]
    },
    {
      "name": "RequestTransitionEvent",
      "return": "bool",
      "doc": "Attempts to queue a transition request, returns true if the request was successful",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "EventName",
          "type": "FName"
        },
        {
          "name": "RequestTimeout",
          "type": "float"
        },
        {
          "name": "QueueMode",
          "type": "ETransitionRequestQueueMode"
        },
        {
          "name": "OverwriteMode",
          "type": "ETransitionRequestOverwriteMode"
        }
      ]
    },
    {
      "name": "ResetDynamics",
      "return": "void",
      "doc": "Reset any dynamics running simulation-style updates (e.g. on teleport, time skip etc.)",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "InTeleportType",
          "type": "ETeleportType"
        }
      ]
    },
    {
      "name": "SavePoseSnapshot",
      "return": "void",
      "doc": "Takes a snapshot of the current skeletal mesh component pose & saves it internally.\nThis snapshot can then be retrieved by name in the animation blueprint for blending.\nThe snapshot is taken at the current LOD, so if for example you took the snapshot at LOD1 and then used it at LOD0 any bones not in LOD1 will use the reference pose",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "SnapshotName",
          "type": "FName"
        }
      ]
    },
    {
      "name": "SetMorphTarget",
      "return": "void",
      "doc": "Sets a morph target to a certain weight.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "MorphTargetName",
          "type": "FName"
        },
        {
          "name": "Value",
          "type": "float32"
        }
      ]
    },
    {
      "name": "SetPropagateNotifiesToLinkedInstances",
      "return": "void",
      "doc": "Set whether to propagate notifies to any linked anim instances",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "bSet",
          "type": "bool"
        }
      ]
    },
    {
      "name": "SetReceiveNotifiesFromLinkedInstances",
      "return": "void",
      "doc": "Set whether to process notifies from any linked anim instances",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "bSet",
          "type": "bool"
        }
      ]
    },
    {
      "name": "SetRootMotionMode",
      "return": "void",
      "doc": "Set RootMotionMode",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Value",
          "type": "ERootMotionMode"
        }
      ]
    },
    {
      "name": "SetUseMainInstanceMontageEvaluationData",
      "return": "void",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "bSet",
          "type": "bool"
        }
      ]
    },
    {
      "name": "SnapshotPose",
      "return": "void",
      "doc": "Takes a snapshot of the current skeletal mesh component pose and saves it to the specified snapshot.\nThe snapshot is taken at the current LOD, so if for example you took the snapshot at LOD1\nand then used it at LOD0 any bones not in LOD1 will use the reference pose",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Snapshot",
          "type": "FPoseSnapshot&"
        }
      ]
    },
    {
      "name": "StopSlotAnimation",
      "return": "void",
      "doc": "Stops currently playing slot animation slot or all",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "InBlendOutTime",
          "default": "0.250000",
          "type": "float32"
        },
        {
          "name": "SlotNodeName",
          "default": "NAME_None",
          "type": "FName"
        }
      ]
    },
    {
      "name": "TryGetPawnOwner",
      "return": "APawn",
      "const": true,
      "doc": "kismet event functions",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "UnlinkAnimClassLayers",
      "return": "void",
      "doc": "Runs through all layer nodes, attempting to find layer nodes that are currently running the specified class, then resets each to its default value.\nState sharing rules are as with SetLayerOverlay.\nIf InClass is null, does nothing.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "InClass",
          "type": "TSubclassOf<UAnimInstance>"
        }
      ]
    },
    {
      "name": "WasAnimNotifyStateActiveInAnyState",
      "return": "bool",
      "doc": "Get whether a particular notify state was active in any state machine last tick.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "AnimNotifyStateType",
          "type": "TSubclassOf<UAnimNotifyState>"
        }
      ]
    }
  ]
}