{
  "name": "UCharacterMovementComponent",
  "inherits": "UPawnMovementComponent",
  "doc": "CharacterMovementComponent handles movement logic for the associated Character owner.\nIt supports various movement modes including: walking, falling, swimming, flying, custom.\n\nMovement is affected primarily by current Velocity and Acceleration. Acceleration is updated each frame\nbased on the input vector accumulated thus far (see UPawnMovementComponent::GetPendingInputVector()).\n\nNetworking is fully implemented, with server-client correction and prediction included.\n\n@see ACharacter, UPawnMovementComponent\n@see https://docs.unrealengine.com/latest/INT/Gameplay/Framework/Pawn/Character/",
  "properties": {
    "GravityScale": [
      "float32",
      "Custom gravity scale. Gravity is multiplied by this amount for the character."
    ],
    "MaxStepHeight": [
      "float32",
      "Maximum height character can step up"
    ],
    "JumpZVelocity": [
      "float32",
      "Initial velocity (instantaneous vertical acceleration) when jumping."
    ],
    "JumpOffJumpZFactor": [
      "float32",
      "Fraction of JumpZVelocity to use when automatically \"jumping off\" of a base actor that's not allowed to be a base for a character. (For example, if you're not allowed to stand on other players.)"
    ],
    "WorldToGravityTransform": [
      "FQuat",
      1,
      "A cached quaternion representing the rotation from world space to gravity relative space defined by GravityDirection."
    ],
    "GravityToWorldTransform": [
      "FQuat",
      1,
      "A cached quaternion representing the inverse rotation from world space to gravity relative space defined by GravityDirection."
    ],
    "CustomMovementMode": [
      "uint8",
      1,
      "Current custom sub-mode if MovementMode is set to Custom.\nThis is automatically replicated through the Character owner and for client-server movement functions.\n@see SetMovementMode()"
    ],
    "NetworkSmoothingMode": [
      "ENetworkSmoothingMode",
      "Smoothing mode for simulated proxies in network game."
    ],
    "GroundFriction": [
      "float32",
      "Setting that affects movement control. Higher values allow faster changes in direction.\nIf bUseSeparateBrakingFriction is false, also affects the ability to stop more quickly when braking (whenever Acceleration is zero), where it is multiplied by BrakingFrictionFactor.\nWhen braking, this property allows you to control how much friction is applied when moving across the ground, applying an opposing force that scales with current velocity.\nThis can be used to simulate slippery surfaces such as ice or oil by changing the value (possibly based on the material pawn is standing on).\n@see BrakingDecelerationWalking, BrakingFriction, bUseSeparateBrakingFriction, BrakingFrictionFactor"
    ],
    "MaxWalkSpeed": [
      "float32",
      "The maximum ground speed when walking. Also determines maximum lateral speed when falling."
    ],
    "MaxWalkSpeedCrouched": [
      "float32",
      "The maximum ground speed when walking and crouched."
    ],
    "MaxSwimSpeed": [
      "float32",
      "The maximum swimming speed."
    ],
    "MaxFlySpeed": [
      "float32",
      "The maximum flying speed."
    ],
    "MaxCustomMovementSpeed": [
      "float32",
      "The maximum speed when using Custom movement mode."
    ],
    "MinAnalogWalkSpeed": [
      "float32",
      "The ground speed that we should accelerate up to when walking at minimum analog stick tilt"
    ],
    "BrakingFrictionFactor": [
      "float32",
      "Factor used to multiply actual value of friction used when braking.\nThis applies to any friction value that is currently used, which may depend on bUseSeparateBrakingFriction.\n@note This is 2 by default for historical reasons, a value of 1 gives the true drag equation.\n@see bUseSeparateBrakingFriction, GroundFriction, BrakingFriction"
    ],
    "BrakingFriction": [
      "float32",
      "Friction (drag) coefficient applied when braking (whenever Acceleration = 0, or if character is exceeding max speed); actual value used is this multiplied by BrakingFrictionFactor.\nWhen braking, this property allows you to control how much friction is applied when moving across the ground, applying an opposing force that scales with current velocity.\nBraking is composed of friction (velocity-dependent drag) and constant deceleration.\nThis is the current value, used in all movement modes; if this is not desired, override it or bUseSeparateBrakingFriction when movement mode changes.\n@note Only used if bUseSeparateBrakingFriction setting is true, otherwise current friction such as GroundFriction is used.\n@see bUseSeparateBrakingFriction, BrakingFrictionFactor, GroundFriction, BrakingDecelerationWalking"
    ],
    "BrakingSubStepTime": [
      "float32",
      "Time substepping when applying braking friction. Smaller time steps increase accuracy at the slight cost of performance, especially if there are large frame times."
    ],
    "BrakingDecelerationWalking": [
      "float32",
      "Deceleration when walking and not applying acceleration. This is a constant opposing force that directly lowers velocity by a constant value.\n@see GroundFriction, MaxAcceleration"
    ],
    "BrakingDecelerationFalling": [
      "float32",
      "Lateral deceleration when falling and not applying acceleration.\n@see MaxAcceleration"
    ],
    "BrakingDecelerationSwimming": [
      "float32",
      "Deceleration when swimming and not applying acceleration.\n@see MaxAcceleration"
    ],
    "BrakingDecelerationFlying": [
      "float32",
      "Deceleration when flying and not applying acceleration.\n@see MaxAcceleration"
    ],
    "AirControl": [
      "float32",
      "When falling, amount of lateral movement control available to the character.\n0 = no control, 1 = full control at max speed of MaxWalkSpeed."
    ],
    "AirControlBoostMultiplier": [
      "float32",
      "When falling, multiplier applied to AirControl when lateral velocity is less than AirControlBoostVelocityThreshold.\nSetting this to zero will disable air control boosting. Final result is clamped at 1."
    ],
    "AirControlBoostVelocityThreshold": [
      "float32",
      "When falling, if lateral velocity magnitude is less than this value, AirControl is multiplied by AirControlBoostMultiplier.\nSetting this to zero will disable air control boosting."
    ],
    "FallingLateralFriction": [
      "float32",
      "Friction to apply to lateral air movement when falling.\nIf bUseSeparateBrakingFriction is false, also affects the ability to stop more quickly when braking (whenever Acceleration is zero).\n@see BrakingFriction, bUseSeparateBrakingFriction"
    ],
    "Buoyancy": [
      "float32",
      "Water buoyancy. A ratio (1.0 = neutral buoyancy, 0.0 = no buoyancy)"
    ],
    "PerchAdditionalHeight": [
      "float32",
      "When perching on a ledge, add this additional distance to MaxStepHeight when determining how high above a walkable floor we can perch.\nNote that we still enforce MaxStepHeight to start the step up; this just allows the character to hang off the edge or step slightly higher off the floor.\n(@see PerchRadiusThreshold)"
    ],
    "RotationRate": [
      "FRotator",
      "Change in rotation per second, used when UseControllerDesiredRotation or OrientRotationToMovement are true. Set a negative value for infinite rotation rate and instant turns."
    ],
    "MaxOutOfWaterStepHeight": [
      "float32",
      "Maximum step height for getting out of water"
    ],
    "OutofWaterZ": [
      "float32",
      "Z velocity applied when pawn tries to get out of water"
    ],
    "Mass": [
      "float32",
      "Mass of pawn (for when momentum is imparted to it)."
    ],
    "StandingDownwardForceScale": [
      "float32",
      "Force applied to objects we stand on (due to Mass and Gravity) is scaled by this amount."
    ],
    "InitialPushForceFactor": [
      "float32",
      "Initial impulse force to apply when the player bounces into a blocking physics object."
    ],
    "PushForceFactor": [
      "float32",
      "Force to apply when the player collides with a blocking physics object."
    ],
    "PushForcePointZOffsetFactor": [
      "float32",
      "Z-Offset for the position the force is applied to. 0.0f is the center of the physics object, 1.0f is the top and -1.0f is the bottom of the object."
    ],
    "TouchForceFactor": [
      "float32",
      "Force to apply to physics objects that are touched by the player."
    ],
    "MinTouchForce": [
      "float32",
      "Minimum Force applied to touched physics objects. If < 0.0f, there is no minimum."
    ],
    "MaxTouchForce": [
      "float32",
      "Maximum force applied to touched physics objects. If < 0.0f, there is no maximum."
    ],
    "RepulsionForce": [
      "float32",
      "Force per kg applied constantly to all overlapping components."
    ],
    "MaxSimulationTimeStep": [
      "float32",
      "Max time delta for each discrete simulation step.\nUsed primarily in the the more advanced movement modes that break up larger time steps (usually those applying gravity such as falling and walking).\nLowering this value can address issues with fast-moving objects or complex collision scenarios, at the cost of performance.\n\nWARNING: if (MaxSimulationTimeStep * MaxSimulationIterations) is too low for the min framerate, the last simulation step may exceed MaxSimulationTimeStep to complete the simulation.\n@see MaxSimulationIterations"
    ],
    "MaxSimulationIterations": [
      "int",
      "Max number of iterations used for each discrete simulation step.\nUsed primarily in the the more advanced movement modes that break up larger time steps (usually those applying gravity such as falling and walking).\nIncreasing this value can address issues with fast-moving objects or complex collision scenarios, at the cost of performance.\n\nWARNING: if (MaxSimulationTimeStep * MaxSimulationIterations) is too low for the min framerate, the last simulation step may exceed MaxSimulationTimeStep to complete the simulation.\n@see MaxSimulationTimeStep"
    ],
    "MaxJumpApexAttemptsPerSimulation": [
      "int",
      "Max number of attempts per simulation to attempt to exactly reach the jump apex when falling movement reaches the top of the arc.\nLimiting this prevents deep recursion when special cases cause collision or other conditions which reactivate the apex condition."
    ],
    "MaxDepenetrationWithGeometry": [
      "float32",
      "Max distance we allow simulated proxies to depenetrate when moving out of anything but Pawns.\nThis is generally more tolerant than with Pawns, because other geometry is either not moving, or is moving predictably with a bit of delay compared to on the server.\n@see MaxDepenetrationWithGeometryAsProxy, MaxDepenetrationWithPawn, MaxDepenetrationWithPawnAsProxy"
    ],
    "MaxDepenetrationWithGeometryAsProxy": [
      "float32",
      "Max distance we allow simulated proxies to depenetrate when moving out of anything but Pawns.\nThis is generally more tolerant than with Pawns, because other geometry is either not moving, or is moving predictably with a bit of delay compared to on the server.\n@see MaxDepenetrationWithGeometry, MaxDepenetrationWithPawn, MaxDepenetrationWithPawnAsProxy"
    ],
    "MaxDepenetrationWithPawn": [
      "float32",
      "Max distance we are allowed to depenetrate when moving out of other Pawns.\n@see MaxDepenetrationWithGeometry, MaxDepenetrationWithGeometryAsProxy, MaxDepenetrationWithPawnAsProxy"
    ],
    "MaxDepenetrationWithPawnAsProxy": [
      "float32",
      "Max distance we allow simulated proxies to depenetrate when moving out of other Pawns.\nTypically we don't want a large value, because we receive a server authoritative position that we should not then ignore by pushing them out of the local player.\n@see MaxDepenetrationWithGeometry, MaxDepenetrationWithGeometryAsProxy, MaxDepenetrationWithPawn"
    ],
    "NetworkSimulatedSmoothLocationTime": [
      "float32",
      2,
      "How long to take to smoothly interpolate from the old pawn position on the client to the corrected one sent by the server. Not used by Linear smoothing."
    ],
    "NetworkSimulatedSmoothRotationTime": [
      "float32",
      2,
      "How long to take to smoothly interpolate from the old pawn rotation on the client to the corrected one sent by the server. Not used by Linear smoothing."
    ],
    "ListenServerNetworkSimulatedSmoothLocationTime": [
      "float32",
      2,
      "Similar setting as NetworkSimulatedSmoothLocationTime but only used on Listen servers."
    ],
    "ListenServerNetworkSimulatedSmoothRotationTime": [
      "float32",
      2,
      "Similar setting as NetworkSimulatedSmoothRotationTime but only used on Listen servers."
    ],
    "NetProxyShrinkRadius": [
      "float32",
      2,
      "Shrink simulated proxy capsule radius by this amount, to account for network rounding that may cause encroachment. Changing during gameplay is not supported.\n@see AdjustProxyCapsuleSize()"
    ],
    "NetProxyShrinkHalfHeight": [
      "float32",
      2,
      "Shrink simulated proxy capsule half height by this amount, to account for network rounding that may cause encroachment. Changing during gameplay is not supported.\n@see AdjustProxyCapsuleSize()"
    ],
    "NetworkMaxSmoothUpdateDistance": [
      "float32",
      2,
      "Maximum distance character is allowed to lag behind server location when interpolating between updates."
    ],
    "NetworkNoSmoothUpdateDistance": [
      "float32",
      2,
      "Maximum distance beyond which character is teleported to the new server location without any smoothing."
    ],
    "NetworkMinTimeBetweenClientAckGoodMoves": [
      "float32",
      2,
      "Minimum time on the server between acknowledging good client moves. This can save on bandwidth. Set to 0 to disable throttling."
    ],
    "NetworkMinTimeBetweenClientAdjustments": [
      "float32",
      2,
      "Minimum time on the server between sending client adjustments when client has exceeded allowable position error.\nShould be >= NetworkMinTimeBetweenClientAdjustmentsLargeCorrection (the larger value is used regardless).\nThis can save on bandwidth. Set to 0 to disable throttling.\n@see ServerLastClientAdjustmentTime"
    ],
    "NetworkMinTimeBetweenClientAdjustmentsLargeCorrection": [
      "float32",
      2,
      "Minimum time on the server between sending client adjustments when client has exceeded allowable position error by a large amount (NetworkLargeClientCorrectionDistance).\nShould be <= NetworkMinTimeBetweenClientAdjustments (the smaller value is used regardless).\n@see NetworkMinTimeBetweenClientAdjustments"
    ],
    "NetworkLargeClientCorrectionDistance": [
      "float32",
      2,
      "If client error is larger than this, sets bNetworkLargeClientCorrection to reduce delay between client adjustments.\n@see NetworkMinTimeBetweenClientAdjustments, NetworkMinTimeBetweenClientAdjustmentsLargeCorrection"
    ],
    "LedgeCheckThreshold": [
      "float32",
      "Used in determining if pawn is going off ledge.  If the ledge is \"shorter\" than this value then the pawn will be able to walk off it. *"
    ],
    "JumpOutOfWaterPitch": [
      "float32",
      "When exiting water, jump if control pitch angle is this high or above."
    ],
    "CurrentFloor": [
      "FFindFloorResult",
      1,
      "Information about the floor the Character is standing on (updated only during walking movement)."
    ],
    "DefaultLandMovementMode": [
      "EMovementMode",
      "Default movement mode when not in water. Used at player startup or when teleported.\n@see DefaultWaterMovementMode\n@see bRunPhysicsWithNoController"
    ],
    "DefaultWaterMovementMode": [
      "EMovementMode",
      "Default movement mode when in water. Used at player startup or when teleported.\n@see DefaultLandMovementMode\n@see bRunPhysicsWithNoController"
    ],
    "FormerBaseVelocityDecayHalfLife": [
      "float32",
      "When applying a root motion override while falling off a moving object, this controls how long it takes to lose half the former base's velocity (in seconds).\nSet to 0 to ignore former bases (default).\nSet to -1 for no decay.\nAny other positive value sets the half-life for exponential decay."
    ],
    "AvoidanceConsiderationRadius": [
      "float32"
    ],
    "AvoidanceUID": [
      "int",
      1,
      "No default value, for now it's assumed to be valid if GetAvoidanceManager() returns non-NULL."
    ],
    "AvoidanceWeight": [
      "float32",
      "De facto default value 0.5 (due to that being the default in the avoidance registration function), indicates RVO behavior."
    ],
    "NavMeshProjectionInterval": [
      "float32",
      "How often we should raycast to project from navmesh to underlying geometry"
    ],
    "NavMeshProjectionInterpSpeed": [
      "float32",
      "Speed at which to interpolate agent navmesh offset between traces. 0: Instant (no interp) > 0: Interp speed\")"
    ],
    "NavMeshProjectionHeightScaleUp": [
      "float32",
      "Scale of the total capsule height to use for projection from navmesh to underlying geometry in the upward direction.\nIn other words, start the trace at [CapsuleHeight * NavMeshProjectionHeightScaleUp] above nav mesh."
    ],
    "NavMeshProjectionHeightScaleDown": [
      "float32",
      "Scale of the total capsule height to use for projection from navmesh to underlying geometry in the downward direction.\nIn other words, trace down to [CapsuleHeight * NavMeshProjectionHeightScaleDown] below nav mesh."
    ],
    "NavWalkingFloorDistTolerance": [
      "float32",
      "Ignore small differences in ground height between server and client data during NavWalking mode"
    ],
    "bBasedMovementIgnorePhysicsBase": [
      "bool",
      "Property to set if UpdateBasedMovement should ignore collision with actors part of the current MovementBase, if the base is simulated by physics"
    ],
    "bStayBasedInAir": [
      "bool",
      "Property to set if characters should stay based on objects while jumping"
    ],
    "StayBasedInAirHeight": [
      "float32",
      "Property used to set how high above base characters should stay based on objects while jumping if bStayBasedInAir is set"
    ],
    "MovementMode": [
      "EMovementMode",
      "Actor's current movement mode (walking, falling, etc).\n   - walking:  Walking on a surface, under the effects of friction, and able to \"step up\" barriers. Vertical velocity is zero.\n   - falling:  Falling under the effects of gravity, after jumping or walking off the edge of a surface.\n   - flying:   Flying, ignoring the effects of gravity.\n   - swimming: Swimming through a fluid volume, under the effects of gravity and buoyancy.\n   - custom:   User-defined custom movement mode, including many possible sub-modes.\nThis is automatically replicated through the Character owner and for client-server movement functions.\n@see SetMovementMode(), CustomMovementMode"
    ],
    "MaxAcceleration": [
      "float32",
      "Max Acceleration (rate of change of velocity)"
    ],
    "PerchRadiusThreshold": [
      "float32",
      "Don't allow the character to perch on the edge of a surface if the contact is this close to the edge of the capsule.\nNote that characters will not fall off if they are within MaxStepHeight of a walkable surface below."
    ],
    "bUseSeparateBrakingFriction": [
      "bool",
      "If true, BrakingFriction will be used to slow the character to a stop (when there is no Acceleration).\nIf false, braking uses the same friction passed to CalcVelocity() (ie GroundFriction when walking), multiplied by BrakingFrictionFactor.\nThis setting applies to all movement modes; if only desired in certain modes, consider toggling it when movement modes change.\n@see BrakingFriction"
    ],
    "bApplyGravityWhileJumping": [
      "bool",
      "Apply gravity while the character is actively jumping (e.g. holding the jump key).\nHelps remove frame-rate dependent jump height, but may alter base jump height."
    ],
    "bUseControllerDesiredRotation": [
      "bool",
      "If true, smoothly rotate the Character toward the Controller's desired rotation (typically Controller->ControlRotation), using RotationRate as the rate of rotation change. Overridden by OrientRotationToMovement.\nNormally you will want to make sure that other settings are cleared, such as bUseControllerRotationYaw on the Character."
    ],
    "bOrientRotationToMovement": [
      "bool",
      "If true, rotate the Character toward the direction of acceleration, using RotationRate as the rate of rotation change. Overrides UseControllerDesiredRotation.\nNormally you will want to make sure that other settings are cleared, such as bUseControllerRotationYaw on the Character."
    ],
    "bSweepWhileNavWalking": [
      "bool",
      "Whether or not the character should sweep for collision geometry while walking.\n@see USceneComponent::MoveComponent."
    ],
    "bEnableScopedMovementUpdates": [
      "bool",
      "If true, high-level movement updates will be wrapped in a movement scope that accumulates updates and defers a bulk of the work until the end.\nWhen enabled, touch and hit events will not be triggered until the end of multiple moves within an update, which can improve performance.\n\n@see FScopedMovementUpdate"
    ],
    "bEnableServerDualMoveScopedMovementUpdates": [
      "bool",
      "Optional scoped movement update to combine moves for cheaper performance on the server when the client sends two moves in one packet.\nBe warned that since this wraps a larger scope than is normally done with bEnableScopedMovementUpdates, this can result in subtle changes in behavior\nin regards to when overlap events are handled, when attached components are moved, etc.\n\n@see bEnableScopedMovementUpdates"
    ],
    "bRunPhysicsWithNoController": [
      "bool",
      "If true, movement will be performed even if there is no Controller for the Character owner.\nNormally without a Controller, movement will be aborted and velocity and acceleration are zeroed if the character is walking.\nCharacters that are spawned without a Controller but with this flag enabled will initialize the movement mode to DefaultLandMovementMode or DefaultWaterMovementMode appropriately.\n@see DefaultLandMovementMode, DefaultWaterMovementMode"
    ],
    "bForceNextFloorCheck": [
      "bool",
      "Force the Character in MOVE_Walking to do a check for a valid floor even if it hasn't moved. Cleared after next floor check.\nNormally if bAlwaysCheckFloor is false we try to avoid the floor check unless some conditions are met, but this can be used to force the next check to always run."
    ],
    "bCanWalkOffLedges": [
      "bool",
      "If true, Character can walk off a ledge."
    ],
    "bCanWalkOffLedgesWhenCrouching": [
      "bool",
      "If true, Character can walk off a ledge when crouching."
    ],
    "bNetworkSkipProxyPredictionOnNetUpdate": [
      "bool",
      "Whether we skip prediction on frames where a proxy receives a network update. This can avoid expensive prediction on those frames,\nwith the side-effect of predicting with a frame of additional latency."
    ],
    "bNetworkAlwaysReplicateTransformUpdateTimestamp": [
      "bool",
      "Flag used on the server to determine whether to always replicate ReplicatedServerLastTransformUpdateTimeStamp to clients.\nNormally this is only sent when the network smoothing mode on character movement is set to Linear smoothing (on the server), to save bandwidth.\nSetting this to true will force the timestamp to replicate regardless, in case the server doesn't know about the smoothing mode, or if the timestamp is used for another purpose."
    ],
    "bEnablePhysicsInteraction": [
      "bool",
      "If enabled, the player will interact with physics objects when walking into them."
    ],
    "bTouchForceScaledToMass": [
      "bool",
      "If enabled, the TouchForceFactor is applied per kg mass of the affected object."
    ],
    "bPushForceScaledToMass": [
      "bool",
      "If enabled, the PushForceFactor is applied per kg mass of the affected object."
    ],
    "bPushForceUsingZOffset": [
      "bool",
      "If enabled, the PushForce location is moved using PushForcePointZOffsetFactor. Otherwise simply use the impact point."
    ],
    "bScalePushForceToVelocity": [
      "bool",
      "If enabled, the applied push force will try to get the physics object to the same velocity than the player, not faster. This will only\n              scale the force down, it will never apply more force than defined by PushForceFactor."
    ],
    "bMaintainHorizontalGroundVelocity": [
      "bool",
      "If true, walking movement always maintains horizontal velocity when moving up ramps, which causes movement up ramps to be faster parallel to the ramp surface.\nIf false, then walking movement maintains velocity magnitude parallel to the ramp surface."
    ],
    "bImpartBaseVelocityX": [
      "bool",
      "If true, impart the base actor's X velocity when falling off it (which includes jumping)"
    ],
    "bImpartBaseVelocityY": [
      "bool",
      "If true, impart the base actor's Y velocity when falling off it (which includes jumping)"
    ],
    "bImpartBaseVelocityZ": [
      "bool",
      "If true, impart the base actor's Z velocity when falling off it (which includes jumping)"
    ],
    "bImpartBaseAngularVelocity": [
      "bool",
      "If true, impart the base component's tangential components of angular velocity when jumping or falling off it.\nOnly those components of the velocity allowed by the separate component settings (bImpartBaseVelocityX etc) will be applied.\n@see bImpartBaseVelocityX, bImpartBaseVelocityY, bImpartBaseVelocityZ"
    ],
    "bJustTeleported": [
      "bool",
      "Used by movement code to determine if a change in position is based on normal movement or a teleport. If not a teleport, velocity can be recomputed based on the change in position."
    ],
    "bIgnoreClientMovementErrorChecksAndCorrection": [
      "bool",
      "If true, we should ignore server location difference checks for client error on this movement component.\nThis can be useful when character is moving at extreme speeds for a duration and you need it to look\nsmooth on clients without the server correcting the client. Make sure to disable when done, as this would\nbreak this character's server-client movement correction.\n@see bServerAcceptClientAuthoritativePosition, ServerCheckClientError()"
    ],
    "bServerAcceptClientAuthoritativePosition": [
      "bool",
      "If true, and server does not detect client position error, server will copy the client movement location/velocity/etc after simulating the move.\nThis can be useful for short bursts of movement that are difficult to sync over the network.\nNote that if bIgnoreClientMovementErrorChecksAndCorrection is used, this means the server will not detect an error.\nAlso see GameNetworkManager->ClientAuthorativePosition which permanently enables this behavior.\n@see bIgnoreClientMovementErrorChecksAndCorrection, ServerShouldUseAuthoritativePosition()"
    ],
    "bNotifyApex": [
      "bool",
      "If true, event NotifyJumpApex() to CharacterOwner's controller when at apex of jump. Is cleared when event is triggered.\nBy default this is off, and if you want the event to fire you typically set it to true when movement mode changes to \"Falling\" from another mode (see OnMovementModeChanged)."
    ],
    "bWantsToCrouch": [
      "bool",
      "If true, try to crouch (or keep crouching) on next update. If false, try to stop crouching on next update."
    ],
    "bCrouchMaintainsBaseLocation": [
      "bool",
      "If true, crouching should keep the base of the capsule in place by lowering the center of the shrunken capsule. If false, the base of the capsule moves up and the center stays in place.\nThe same behavior applies when the character uncrouches: if true, the base is kept in the same location and the center moves up. If false, the capsule grows and only moves up if the base impacts something.\nBy default this variable is set when the movement mode changes: set to true when walking and false otherwise. Feel free to override the behavior when the movement mode changes."
    ],
    "bIgnoreBaseRotation": [
      "bool",
      "Whether the character ignores changes in rotation of the base it is standing on.\nIf true, the character maintains current world rotation.\nIf false, the character rotates with the moving base."
    ],
    "bAlwaysCheckFloor": [
      "bool",
      "Whether we always force floor checks for stationary Characters while walking.\nNormally floor checks are avoided if possible when not moving, but this can be used to force them if there are use-cases where they are being skipped erroneously\n(such as objects moving up into the character from below)."
    ],
    "bUseFlatBaseForFloorChecks": [
      "bool",
      "Performs floor checks as if the character is using a shape with a flat base.\nThis avoids the situation where characters slowly lower off the side of a ledge (as their capsule 'balances' on the edge)."
    ],
    "bUseRVOAvoidance": [
      "bool",
      "If set, component will use RVO avoidance. This only runs on the server."
    ],
    "bRequestedMoveUseAcceleration": [
      "bool",
      "Should use acceleration for path following?\nIf true, acceleration is applied when path following to reach the target velocity.\nIf false, path following velocity is set directly, disregarding acceleration."
    ],
    "bAllowPhysicsRotationDuringAnimRootMotion": [
      "bool"
    ],
    "bProjectNavMeshWalking": [
      "bool",
      "Whether to raycast to underlying geometry to better conform navmesh-walking characters"
    ],
    "bProjectNavMeshOnBothWorldChannels": [
      "bool",
      "Use both WorldStatic and WorldDynamic channels for NavWalking geometry conforming"
    ],
    "AvoidanceGroup": [
      "FNavAvoidanceMask",
      "Moving actor's group mask"
    ],
    "GroupsToAvoid": [
      "FNavAvoidanceMask",
      "Will avoid other agents if they are in one of specified groups"
    ],
    "GroupsToIgnore": [
      "FNavAvoidanceMask",
      "Will NOT avoid other agents if they are in one of specified groups, higher priority than GroupsToAvoid"
    ]
  },
  "methods": [
    {
      "name": "AddForce",
      "return": "void",
      "doc": "Add force to character. Forces are accumulated each tick and applied together\nso multiple calls to this function will accumulate.\nForces are scaled depending on timestep, so they can be applied each frame. If you want an\ninstantaneous force, use AddImpulse.\nAdding a force always takes the actor's mass into account.\nNote that changing the momentum of characters like this can change the movement mode.\n\n@param       Force                   Force to apply.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Force",
          "type": "FVector"
        }
      ]
    },
    {
      "name": "AddImpulse",
      "return": "void",
      "doc": "Add impulse to character. Impulses are accumulated each tick and applied together\nso multiple calls to this function will accumulate.\nAn impulse is an instantaneous force, usually applied once. If you want to continually apply\nforces each frame, use AddForce().\nNote that changing the momentum of characters like this can change the movement mode.\n\n@param       Impulse                         Impulse to apply.\n@param       bVelocityChange         Whether or not the impulse is relative to mass.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Impulse",
          "type": "FVector"
        },
        {
          "name": "bVelocityChange",
          "default": "false",
          "type": "bool"
        }
      ]
    },
    {
      "name": "CalcVelocity",
      "return": "void",
      "doc": "Updates Velocity and Acceleration based on the current state, applying the effects of friction and acceleration or deceleration. Does not apply gravity.\nThis is used internally during movement updates. Normally you don't need to call this from outside code, but you might want to use it for custom movement modes.\n\n@param       DeltaTime                                               time elapsed since last frame.\n@param       Friction                                                coefficient of friction when not accelerating, or in the direction opposite acceleration.\n@param       bFluid                                                  true if moving through a fluid, causing Friction to always be applied regardless of acceleration.\n@param       BrakingDeceleration                             deceleration applied when not accelerating, or when exceeding max velocity.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "DeltaTime",
          "type": "float32"
        },
        {
          "name": "Friction",
          "type": "float32"
        },
        {
          "name": "bFluid",
          "type": "bool"
        },
        {
          "name": "BrakingDeceleration",
          "type": "float32"
        }
      ]
    },
    {
      "name": "ClearAccumulatedForces",
      "return": "void",
      "doc": "Clears forces accumulated through AddImpulse() and AddForce(), and also pending launch velocity.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "DisableMovement",
      "return": "void",
      "doc": "Make movement impossible (sets movement mode to MOVE_None).",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetAnalogInputModifier",
      "return": "float32",
      "const": true,
      "doc": "Returns modifier [0..1] based on the magnitude of the last input vector, which is used to modify the acceleration and max speed during movement.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetCharacterOwner",
      "return": "ACharacter",
      "const": true,
      "doc": "Get the Character that owns UpdatedComponent.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetCrouchedHalfHeight",
      "return": "float32",
      "const": true,
      "doc": "Returns the collision half-height when crouching (component scale is applied separately)",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetCurrentAcceleration",
      "return": "FVector",
      "const": true,
      "doc": "Returns current acceleration, computed from input vector each update.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetGravityDirection",
      "return": "FVector",
      "const": true,
      "doc": "Returns the current gravity direction.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetImpartedMovementBaseVelocity",
      "return": "FVector",
      "const": true,
      "doc": "If we have a movement base, get the velocity that should be imparted by that base, usually when jumping off of it.\nOnly applies the components of the velocity enabled by bImpartBaseVelocityX, bImpartBaseVelocityY, bImpartBaseVelocityZ.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetLastUpdateLocation",
      "return": "FVector",
      "const": true,
      "doc": "Returns the location at the end of the last tick.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetLastUpdateRequestedVelocity",
      "return": "FVector",
      "const": true,
      "doc": "Returns velocity requested by path following",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetLastUpdateRotation",
      "return": "FRotator",
      "const": true,
      "doc": "Returns the rotation at the end of the last tick.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetLastUpdateVelocity",
      "return": "FVector",
      "const": true,
      "doc": "Returns the velocity at the end of the last tick.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetMaxAcceleration",
      "return": "float32",
      "const": true,
      "doc": "Returns maximum acceleration for the current state.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetMaxBrakingDeceleration",
      "return": "float32",
      "const": true,
      "doc": "Returns maximum deceleration for the current state when braking (ie when there is no acceleration).",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetMaxJumpHeight",
      "return": "float32",
      "const": true,
      "doc": "Compute the max jump height based on the JumpZVelocity velocity and gravity.\nThis does not take into account the CharacterOwner's MaxJumpHoldTime.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetMaxJumpHeightWithJumpTime",
      "return": "float32",
      "const": true,
      "doc": "Compute the max jump height based on the JumpZVelocity velocity and gravity.\nThis does take into account the CharacterOwner's MaxJumpHoldTime.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetMinAnalogSpeed",
      "return": "float32",
      "const": true,
      "doc": "Returns maximum acceleration for the current state.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetMovementBase",
      "return": "UPrimitiveComponent",
      "const": true,
      "doc": "Return PrimitiveComponent we are based on (standing and walking on).",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetPerchRadiusThreshold",
      "return": "float32",
      "const": true,
      "doc": "Returns The distance from the edge of the capsule within which we don't allow the character to perch on the edge of a surface.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetValidPerchRadius",
      "return": "float32",
      "const": true,
      "doc": "Returns the radius within which we can stand on the edge of a surface without falling (if this is a walkable surface).\nSimply computed as the capsule radius minus the result of GetPerchRadiusThreshold().",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "HasCustomGravity",
      "return": "bool",
      "const": true,
      "doc": "Whether the gravity direction is different from UCharacterMovementComponent::DefaultGravityDirection.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "IsWalkable",
      "return": "bool",
      "const": true,
      "doc": "Return true if the hit result should be considered a walkable surface for the character.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Hit",
          "type": "FHitResult"
        }
      ]
    },
    {
      "name": "IsWalking",
      "return": "bool",
      "const": true,
      "doc": "Returns true if the character is in the 'Walking' movement mode.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "ComputeFloorDistance",
      "return": "void",
      "const": true,
      "doc": "Compute distance to the floor from bottom sphere of capsule and store the result in FloorResult.\nThis distance is the swept distance of the capsule to the first point impacted by the lower hemisphere, or distance from the bottom of the capsule in the case of a line trace.\nThis function does not care if collision is disabled on the capsule (unlike FindFloor).\n\n@param CapsuleLocation                Location where the capsule sweep should originate\n@param LineDistance                   If non-zero, max distance to test for a simple line check from the capsule base. Used only if the sweep test fails to find a walkable floor, and only returns a valid result if the impact normal is a walkable normal.\n@param SweepDistance                  If non-zero, max distance to use when sweeping a capsule downwards for the test. MUST be greater than or equal to the line distance.\n@param SweepRadius                    The radius to use for sweep tests. Should be <= capsule radius.\n@param FloorResult                    Result of the floor check",
      "ufunction": true,
      "unrealname": "K2_ComputeFloorDist",
      "meta": null,
      "args": [
        {
          "name": "CapsuleLocation",
          "type": "FVector"
        },
        {
          "name": "LineDistance",
          "type": "float32"
        },
        {
          "name": "SweepDistance",
          "type": "float32"
        },
        {
          "name": "SweepRadius",
          "type": "float32"
        },
        {
          "name": "FloorResult",
          "type": "FFindFloorResult&"
        }
      ]
    },
    {
      "name": "FindFloor",
      "return": "void",
      "const": true,
      "doc": "Sweeps a vertical trace to find the floor for the capsule at the given location. Will attempt to perch if ShouldComputePerchResult() returns true for the downward sweep result.\nNo floor will be found if collision is disabled on the capsule!\n\n@param CapsuleLocation                Location where the capsule sweep should originate\n@param FloorResult                    Result of the floor check",
      "ufunction": true,
      "unrealname": "K2_FindFloor",
      "meta": null,
      "args": [
        {
          "name": "CapsuleLocation",
          "type": "FVector"
        },
        {
          "name": "FloorResult",
          "type": "FFindFloorResult&"
        }
      ]
    },
    {
      "name": "GetWalkableFloorAngle",
      "return": "float32",
      "const": true,
      "doc": "Get the max angle in degrees of a walkable surface for the character.",
      "ufunction": true,
      "unrealname": "K2_GetWalkableFloorAngle",
      "meta": null,
      "args": []
    },
    {
      "name": "GetWalkableFloorZ",
      "return": "float32",
      "const": true,
      "doc": "Get the Z component of the normal of the steepest walkable surface for the character. Any lower than this and it is not walkable.",
      "ufunction": true,
      "unrealname": "K2_GetWalkableFloorZ",
      "meta": null,
      "args": []
    },
    {
      "name": "SetAvoidanceEnabled",
      "return": "void",
      "doc": "Change avoidance state and registers in RVO manager if needed",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "bEnable",
          "type": "bool"
        }
      ]
    },
    {
      "name": "SetAvoidanceGroupMask",
      "return": "void",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "GroupMask",
          "type": "FNavAvoidanceMask"
        }
      ]
    },
    {
      "name": "SetCrouchedHalfHeight",
      "return": "void",
      "doc": "Sets collision half-height when crouching and updates dependent computations",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "NewValue",
          "type": "float32"
        }
      ]
    },
    {
      "name": "SetGravityDirection",
      "return": "void",
      "doc": "Set a custom, local gravity direction to use during movement simulation.\nThe gravity direction must be synchronized by external systems between the autonomous\nand authority processes. The gravity direction will be corrected as part of movement\ncorrections should the movement state diverge.\nSetGravityDirection is responsible for initializing cached values used to tranform to\nfrom gravity relative space.\n@param GravityDir            A non-zero vector representing the new gravity direction. The vector will be normalized.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "GravityDir",
          "type": "FVector"
        }
      ]
    },
    {
      "name": "SetGroupsToAvoidMask",
      "return": "void",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "GroupMask",
          "type": "FNavAvoidanceMask"
        }
      ]
    },
    {
      "name": "SetGroupsToIgnoreMask",
      "return": "void",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "GroupMask",
          "type": "FNavAvoidanceMask"
        }
      ]
    },
    {
      "name": "SetMovementMode",
      "return": "void",
      "doc": "Change movement mode.\n\n@param NewMovementMode       The new movement mode\n@param NewCustomMode         The new custom sub-mode, only applicable if NewMovementMode is Custom.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "NewMovementMode",
          "type": "EMovementMode"
        },
        {
          "name": "NewCustomMode",
          "default": "0",
          "type": "uint8"
        }
      ]
    },
    {
      "name": "SetWalkableFloorAngle",
      "return": "void",
      "doc": "Set the max angle in degrees of a walkable surface for the character. Also computes WalkableFloorZ.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "InWalkableFloorAngle",
          "type": "float32"
        }
      ]
    },
    {
      "name": "SetWalkableFloorZ",
      "return": "void",
      "doc": "Set the Z component of the normal of the steepest walkable surface for the character. Also computes WalkableFloorAngle.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "InWalkableFloorZ",
          "type": "float32"
        }
      ]
    }
  ]
}