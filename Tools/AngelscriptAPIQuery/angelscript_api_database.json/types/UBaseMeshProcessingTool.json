{
  "name": "UBaseMeshProcessingTool",
  "inherits": "USingleSelectionTool",
  "doc": "UBaseMeshProcessingTool is a base Tool (ie has no functionality of it's own and must be subclassed)\nthat provides the following structure:\n  - a Background-Compute-With-Preview Temp Actor/Component is created based on the input mesh\n  - The Subclass provides FDynamicMeshOperator instances (via IDynamicMeshOperatorFactory) that process/modify and update this Preview\n  - PropertySets with custom visibility can be registered, and on change will invalidate the current computation\n\nOptional support for a WeightMap property set and tracking of active weight map can be enabled by calling\nAddWeightMapPropertySet(), GetActiveWeightMap() will then return the active WeightMap, and changes to the\nWeightMap selection will invalidate the computation.\n\nMost subclasses will only need to define their PropertySets and implement MakeNewOperator(), see eg SmoothMeshTool for a minimal example\n\nOther functions:\n  - GetInitialMesh() : return reference to copy of initial mesh, used to initialize FDynamicMeshOperator\n  - GetUPreviewMesh() : return the UPreviewMesh inside the background compute (for configuration/etc - should not directly touch the mesh!)\n  - GetPreviewTransform() : return active FTransform on the Preview mesh, should be passed to FDynamicMeshOperator unless it is outputting world position\n  - InvalidateResult() : subclasses call this to notify the base class that current result/computation has been invalidated\n\nThe Base tool will do various optional precomputations or changes to the input mesh, which can be configured by\noverriding various functions below.\n\n  RequiresInitialVtxNormals() : return true (default=false) to calculate per-vertex normals on the input mesh, returned by GetInitialVtxNormals()\n\n  RequiresInitialBoundaryLoops() : return true (default=false) to calculate boundary loops on the input mesh, returned by GetInitialBoundaryLoops()\n\n  RequiresScaleNormalization() : return true (default=true) to apply an initial scale to the input mesh so that it has consistent size\n    before being sent into the computation. Scaling factor (eg for scaling UI constants) can be accessed via GetScaleNormalizationFactor()",
  "properties": {},
  "methods": []
}