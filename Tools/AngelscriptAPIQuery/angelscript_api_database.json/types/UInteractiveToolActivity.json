{
  "name": "UInteractiveToolActivity",
  "inherits": "UInteractionMechanic",
  "doc": "A tool activity is a sort of \"sub-tool\" used to break apart functionality in tools that\nprovide support for different multi-interaction subtasks. It is meant to limit the sprawl\nof switch statements in the base tool, to allow subtasks to be designed similar to how a\ntool might be designed, and to ease extendability.\n\nAn activity has the following expectations:\n- Setup() is called in host tool setup and Shutdown() is called in host tool Shutdown()\n- Start() is called to start the activity (such as when user clicks a button).\n- If the activity returns a result of EStartResult::ActivityRunning on Start(), it will expect\n  Render() and Tick() calls from the host until either (a)- the host calls End() on the activity,\n  or (b)- the activity reaches a stopping point itself and calls NotifyActivitySelfEnded() on the\n  host. The activity should not require Render() and Tick() if it is not running.\n\n Compared to a UInteractionMechanic, a tool activity:\n- Expects that it is the main consumer of input, i.e. takes over the tool. Mechanics, by contrast,\n  are currently often used together with other mechanics, or to support main tool functionality.\n- Should not require the hosting tool to have specific knowledge about it or be heavily involved.\n  Mechanics, by contrast, currently often require tools to use various mechanic-specific getters/setters\n  during the tool.\n\nPassing data back and forth can be done either by letting a tool activity use a specific\ncontext object that the tool can prep in the context store, or by requiring the host to\nimplement specific interfaces (that the activity can check for in Setup()).",
  "properties": {},
  "methods": []
}