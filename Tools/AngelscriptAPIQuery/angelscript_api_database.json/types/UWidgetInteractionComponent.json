{
  "name": "UWidgetInteractionComponent",
  "inherits": "USceneComponent",
  "doc": "This is a component to allow interaction with the Widget Component.  This class allows you to\nsimulate a sort of laser pointer device, when it hovers over widgets it will send the basic signals\nto show as if the mouse were moving on top of it.  You'll then tell the component to simulate key presses,\nlike Left Mouse, down and up, to simulate a mouse click.",
  "properties": {
    "OnHoveredWidgetChanged": [
      "FOnHoveredWidgetChanged",
      "Called when the hovered Widget Component changes.  The interaction component functions at the Slate\nlevel - so it's unable to report anything about what UWidget is under the hit result."
    ],
    "VirtualUserIndex": [
      "int",
      "Represents the Virtual User Index.  Each virtual user should be represented by a different\nindex number, this will maintain separate capture and focus states for them.  Each\ncontroller or finger-tip should get a unique PointerIndex."
    ],
    "PointerIndex": [
      "int",
      "Each user virtual controller or virtual finger tips being simulated should use a different pointer index."
    ],
    "TraceChannel": [
      "ECollisionChannel",
      "The trace channel to use when tracing for widget components in the world."
    ],
    "InteractionDistance": [
      "float32",
      "The distance in game units the component should be able to interact with a widget component."
    ],
    "InteractionSource": [
      "EWidgetInteractionSource",
      "Should we project from the world location of the component?  If you set this to false, you'll\nneed to call SetCustomHitResult(), and provide the result of a custom hit test form whatever\nlocation you wish."
    ],
    "bEnableHitTesting": [
      "bool",
      "Should the interaction component perform hit testing (Automatic or Custom) and attempt to\nsimulate hover - if you were going to emulate a keyboard you would want to turn this option off\nif the virtual keyboard was separate from the virtual pointer device and used a second interaction\ncomponent."
    ],
    "bShowDebug": [
      "bool",
      "Shows some debugging lines and a hit sphere to help you debug interactions."
    ],
    "DebugSphereLineThickness": [
      "float32",
      "Determines the line thickness of the debug sphere."
    ],
    "DebugLineThickness": [
      "float32",
      "Determines the thickness of the debug lines."
    ],
    "DebugColor": [
      "FLinearColor",
      "Determines the color of the debug lines."
    ]
  },
  "methods": [
    {
      "name": "Get2DHitLocation",
      "return": "FVector2D",
      "const": true,
      "doc": "Gets the last hit location on the widget in 2D, local pixel units of the render target.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetHoveredWidgetComponent",
      "return": "UWidgetComponent",
      "const": true,
      "doc": "Get the currently hovered widget component.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetLastHitResult",
      "return": "FHitResult",
      "const": true,
      "doc": "Gets the last hit result generated by the component.  Returns the custom hit result if that was set.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "IsOverFocusableWidget",
      "return": "bool",
      "const": true,
      "doc": "Returns true if a widget under the hit result is focusable.  e.g. Slate widgets that\nreturn true for SupportsKeyboardFocus().",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "IsOverHitTestVisibleWidget",
      "return": "bool",
      "const": true,
      "doc": "Returns true if a widget under the hit result is has a visibility that makes it hit test\nvisible.  e.g. Slate widgets that return true for GetVisibility().IsHitTestVisible().",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "IsOverInteractableWidget",
      "return": "bool",
      "const": true,
      "doc": "Returns true if a widget under the hit result is interactive.  e.g. Slate widgets\nthat return true for IsInteractable().",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "PressAndReleaseKey",
      "return": "bool",
      "doc": "Does both the press and release of a simulated keyboard key.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Key",
          "type": "FKey"
        }
      ]
    },
    {
      "name": "PressKey",
      "return": "bool",
      "doc": "Press a key as if it had come from the keyboard.  Avoid using this for 'a-z|A-Z', things like\nthe Editable Textbox in Slate expect OnKeyChar to be called to signal a specific character being\nsend to the widget.  So for those cases you should use SendKeyChar.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Key",
          "type": "FKey"
        },
        {
          "name": "bRepeat",
          "default": "false",
          "type": "bool"
        }
      ]
    },
    {
      "name": "PressPointerKey",
      "return": "void",
      "doc": "Presses a key as if the mouse/pointer were the source of it.  Normally you would just use\nLeft/Right mouse button for the Key.  However - advanced uses could also be imagined where you\nsend other keys to signal widgets to take special actions if they're under the cursor.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Key",
          "type": "FKey"
        }
      ]
    },
    {
      "name": "ReleaseKey",
      "return": "bool",
      "doc": "Releases a key as if it had been released by the keyboard.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Key",
          "type": "FKey"
        }
      ]
    },
    {
      "name": "ReleasePointerKey",
      "return": "void",
      "doc": "Releases a key as if the mouse/pointer were the source of it.  Normally you would just use\nLeft/Right mouse button for the Key.  However - advanced uses could also be imagined where you\nsend other keys to signal widgets to take special actions if they're under the cursor.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Key",
          "type": "FKey"
        }
      ]
    },
    {
      "name": "ScrollWheel",
      "return": "void",
      "doc": "Sends a scroll wheel event to the widget under the last hit result.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "ScrollDelta",
          "type": "float32"
        }
      ]
    },
    {
      "name": "SendKeyChar",
      "return": "bool",
      "doc": "Transmits a list of characters to a widget by simulating a OnKeyChar event for each key listed in\nthe string.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Characters",
          "type": "FString"
        },
        {
          "name": "bRepeat",
          "default": "false",
          "type": "bool"
        }
      ]
    },
    {
      "name": "SetCustomHitResult",
      "return": "void",
      "doc": "Set custom hit result.  This is only taken into account if InteractionSource is set to EWidgetInteractionSource::Custom.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "HitResult",
          "type": "FHitResult"
        }
      ]
    },
    {
      "name": "SetFocus",
      "return": "void",
      "doc": "Set the focus target of the virtual user managed by this component",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "FocusWidget",
          "type": "UWidget"
        }
      ]
    }
  ]
}