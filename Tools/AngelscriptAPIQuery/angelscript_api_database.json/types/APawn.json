{
  "name": "APawn",
  "inherits": "AActor",
  "doc": "Pawn is the base class of all actors that can be possessed by players or AI.\nThey are the physical representations of players and creatures in a level.\n\n@see https://docs.unrealengine.com/latest/INT/Gameplay/Framework/Pawn/",
  "properties": {
    "BaseEyeHeight": [
      "float32",
      "Base eye height above collision center."
    ],
    "AutoPossessPlayer": [
      "EAutoReceiveInput",
      2,
      "Determines which PlayerController, if any, should automatically possess the pawn when the level starts or when the pawn is spawned.\n@see AutoPossessAI"
    ],
    "AutoPossessAI": [
      "EAutoPossessAI",
      2,
      "Determines when the Pawn creates and is possessed by an AI Controller (on level start, when spawned, etc).\nOnly possible if AIControllerClassRef is set, and ignored if AutoPossessPlayer is enabled.\n@see AutoPossessPlayer"
    ],
    "AIControllerClass": [
      "TSubclassOf<AController>",
      "Default class to use when pawn is controlled by AI."
    ],
    "PlayerState": [
      "APlayerState",
      1,
      "If Pawn is possessed by a player, points to its Player State.  Needed for network play as controllers are not replicated to clients."
    ],
    "LastHitBy": [
      "AController",
      1,
      "Controller of the last Actor that caused us damage."
    ],
    "ReceiveControllerChangedDelegate": [
      "FPawnControllerChangedSignature",
      "Event called after a pawn's controller has changed, on the server and owning client. This will happen at the same time as the delegate on GameInstance"
    ],
    "ReceiveRestartedDelegate": [
      "FPawnRestartedSignature",
      "Event called after a pawn has been restarted, usually by a possession change. This is called on the server for all pawns and the owning client for player pawns"
    ],
    "bUseControllerRotationPitch": [
      "bool",
      "If true, this Pawn's pitch will be updated to match the Controller's ControlRotation pitch, if controlled by a PlayerController."
    ],
    "bUseControllerRotationYaw": [
      "bool",
      "If true, this Pawn's yaw will be updated to match the Controller's ControlRotation yaw, if controlled by a PlayerController."
    ],
    "bUseControllerRotationRoll": [
      "bool",
      "If true, this Pawn's roll will be updated to match the Controller's ControlRotation roll, if controlled by a PlayerController."
    ],
    "bCanAffectNavigationGeneration": [
      "bool",
      "If set to false (default) given pawn instance will never affect navigation generation (but components could).\nSetting it to true will result in using regular AActor's navigation relevancy\ncalculation to check if this pawn instance should affect navigation generation.\n@note Use SetCanAffectNavigationGeneration() to change this value at runtime.\n@note Modifying this value at runtime will result in any navigation change only if runtime navigation generation is enabled.\n@note Override UpdateNavigationRelevance() to propagate the flag to the desired components.\n@see SetCanAffectNavigationGeneration(), UpdateNavigationRelevance()"
    ],
    "OverrideInputComponentClass": [
      "TSubclassOf<UInputComponent>",
      "If set, then this InputComponent class will be used instead of the Input Settings' DefaultInputComponentClass"
    ]
  },
  "methods": [
    {
      "name": "AddControllerPitchInput",
      "return": "void",
      "doc": "Add input (affecting Pitch) to the Controller's ControlRotation, if it is a local PlayerController.\nThis value is multiplied by the PlayerController's InputPitchScale value.\n@param Val Amount to add to Pitch. This value is multiplied by the PlayerController's InputPitchScale value.\n@see PlayerController::InputPitchScale",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Val",
          "type": "float32"
        }
      ]
    },
    {
      "name": "AddControllerRollInput",
      "return": "void",
      "doc": "Add input (affecting Roll) to the Controller's ControlRotation, if it is a local PlayerController.\nThis value is multiplied by the PlayerController's InputRollScale value.\n@param Val Amount to add to Roll. This value is multiplied by the PlayerController's InputRollScale value.\n@see PlayerController::InputRollScale",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Val",
          "type": "float32"
        }
      ]
    },
    {
      "name": "AddControllerYawInput",
      "return": "void",
      "doc": "Add input (affecting Yaw) to the Controller's ControlRotation, if it is a local PlayerController.\nThis value is multiplied by the PlayerController's InputYawScale value.\n@param Val Amount to add to Yaw. This value is multiplied by the PlayerController's InputYawScale value.\n@see PlayerController::InputYawScale",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Val",
          "type": "float32"
        }
      ]
    },
    {
      "name": "AddMovementInput",
      "return": "void",
      "doc": "Add movement input along the given world direction vector (usually normalized) scaled by 'ScaleValue'. If ScaleValue < 0, movement will be in the opposite direction.\nBase Pawn classes won't automatically apply movement, it's up to the user to do so in a Tick event. Subclasses such as Character and DefaultPawn automatically handle this input and move.\n\n@param WorldDirection        Direction in world space to apply input\n@param ScaleValue            Scale to apply to input. This can be used for analog input, ie a value of 0.5 applies half the normal value, while -1.0 would reverse the direction.\n@param bForce                        If true always add the input, ignoring the result of IsMoveInputIgnored().\n@see GetPendingMovementInputVector(), GetLastMovementInputVector(), ConsumeMovementInputVector()",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "WorldDirection",
          "type": "FVector"
        },
        {
          "name": "ScaleValue",
          "default": "1.000000",
          "type": "float32"
        },
        {
          "name": "bForce",
          "default": "false",
          "type": "bool"
        }
      ]
    },
    {
      "name": "ConsumeMovementInputVector",
      "return": "FVector",
      "doc": "Returns the pending input vector and resets it to zero.\nThis should be used during a movement update (by the Pawn or PawnMovementComponent) to prevent accumulation of control input between frames.\nCopies the pending input vector to the saved input vector (GetLastMovementInputVector()).\n@return The pending input vector.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "DetachFromControllerPendingDestroy",
      "return": "void",
      "doc": "Call this function to detach safely pawn from its controller, knowing that we will be destroyed soon.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetBaseAimRotation",
      "return": "FRotator",
      "const": true,
      "doc": "Return the aim rotation for the Pawn.\nIf we have a controller, by default we aim at the player's 'eyes' direction\nthat is by default the Pawn rotation for AI, and camera (crosshair) rotation for human players.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetController",
      "return": "AController",
      "const": true,
      "doc": "Returns controller for this actor.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetControlRotation",
      "return": "FRotator",
      "const": true,
      "doc": "Get the rotation of the Controller, often the 'view' rotation of this Pawn.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetLastMovementInputVector",
      "return": "FVector",
      "const": true,
      "doc": "Return the last input vector in world space that was processed by ConsumeMovementInputVector(), which is usually done by the Pawn or PawnMovementComponent.\nAny user that needs to know about the input that last affected movement should use this function.\nFor example an animation update would want to use this, since by default the order of updates in a frame is:\nPlayerController (device input) -> MovementComponent -> Pawn -> Mesh (animations)\n\n@return The last input vector in world space that was processed by ConsumeMovementInputVector().\n@see AddMovementInput(), GetPendingMovementInputVector(), ConsumeMovementInputVector()",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetLocalViewingPlayerController",
      "return": "APlayerController",
      "const": true,
      "doc": "Returns local Player Controller viewing this pawn, whether it is controlling or spectating",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetMovementComponent",
      "return": "UPawnMovementComponent",
      "const": true,
      "doc": "Return our PawnMovementComponent, if we have one.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetNavAgentLocation",
      "return": "FVector",
      "const": true,
      "doc": "Basically retrieved pawn's location on navmesh",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetOverrideInputComponentClass",
      "return": "TSubclassOf<UInputComponent>",
      "const": true,
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetPendingMovementInputVector",
      "return": "FVector",
      "const": true,
      "doc": "Return the pending input vector in world space. This is the most up-to-date value of the input vector, pending ConsumeMovementInputVector() which clears it,\nUsually only a PawnMovementComponent will want to read this value, or the Pawn itself if it is responsible for movement.\n\n@return The pending input vector in world space.\n@see AddMovementInput(), GetLastMovementInputVector(), ConsumeMovementInputVector()",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetPlatformUserId",
      "return": "FPlatformUserId",
      "const": true,
      "doc": "Returns the Platform User ID of the PlayerController that is controlling this character.\n\nReturns an invalid Platform User ID if this character is not controlled by a local player.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "IsBotControlled",
      "return": "bool",
      "const": true,
      "doc": "Returns true if controlled by a bot.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "IsControlled",
      "return": "bool",
      "const": true,
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "IsLocallyControlled",
      "return": "bool",
      "const": true,
      "doc": "Returns true if controlled by a local (not network) Controller.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "IsLocallyViewed",
      "return": "bool",
      "const": true,
      "doc": "Is this pawn the ViewTarget of a local PlayerController?  Helpful for determining whether the pawn is\nvisible/critical for any VFX.  NOTE: Technically there may be some cases where locally controlled pawns return\nfalse for this, such as if you are using a remote camera view of some sort.  But generally it will be true for\nlocally controlled pawns, and it will always be true for pawns that are being spectated in-game or in Replays.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "IsMoveInputIgnored",
      "return": "bool",
      "const": true,
      "doc": "Helper to see if move input is ignored. If our controller is a PlayerController, checks Controller->IsMoveInputIgnored().",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "IsPawnControlled",
      "return": "bool",
      "const": true,
      "doc": "Check if this actor is currently being controlled at all (the actor has a valid Controller, which will be false for remote clients)",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "IsPlayerControlled",
      "return": "bool",
      "const": true,
      "doc": "Returns true if controlled by a human player (possessed by a PlayerController).        This returns true for players controlled by remote clients",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "PawnMakeNoise",
      "return": "void",
      "doc": "Inform AIControllers that you've made a noise they might hear (they are sent a HearNoise message if they have bHearNoises==true)\nThe instigator of this sound is the pawn which is used to call MakeNoise.\n\n@param Loudness - is the relative loudness of this noise (range 0.0 to 1.0).  Directly affects the hearing range specified by the AI's HearingThreshold.\n@param NoiseLocation - Position of noise source.  If zero vector, use the actor's location.\n@param bUseNoiseMakerLocation - If true, use the location of the NoiseMaker rather than NoiseLocation.  If false, use NoiseLocation.\n@param NoiseMaker - Which actor is the source of the noise.  Not to be confused with the Noise Instigator, which is responsible for the noise (and is the pawn on which this function is called).  If not specified, the pawn instigating the noise will be used as the NoiseMaker",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Loudness",
          "type": "float32"
        },
        {
          "name": "NoiseLocation",
          "type": "FVector"
        },
        {
          "name": "bUseNoiseMakerLocation",
          "default": "true",
          "type": "bool"
        },
        {
          "name": "NoiseMaker",
          "default": "nullptr",
          "type": "AActor"
        }
      ]
    },
    {
      "name": "ControllerChanged",
      "return": "void",
      "callable": false,
      "doc": "Event called after a pawn's controller has changed, on the server and owning client. This will happen at the same time as the delegate on GameInstance",
      "event": true,
      "unrealname": "ReceiveControllerChanged",
      "meta": null,
      "args": [
        {
          "name": "OldController",
          "type": "AController"
        },
        {
          "name": "NewController",
          "type": "AController"
        }
      ]
    },
    {
      "name": "Possessed",
      "return": "void",
      "callable": false,
      "doc": "Event called when the Pawn is possessed by a Controller. Only called on the server (or in standalone)",
      "event": true,
      "unrealname": "ReceivePossessed",
      "meta": null,
      "args": [
        {
          "name": "NewController",
          "type": "AController"
        }
      ]
    },
    {
      "name": "Restarted",
      "return": "void",
      "callable": false,
      "doc": "Event called after a pawn has been restarted, usually by a possession change. This is called on the server for all pawns and the owning client for player pawns",
      "event": true,
      "unrealname": "ReceiveRestarted",
      "meta": null,
      "args": []
    },
    {
      "name": "Unpossessed",
      "return": "void",
      "callable": false,
      "doc": "Event called when the Pawn is no longer possessed by a Controller. Only called on the server (or in standalone)",
      "event": true,
      "unrealname": "ReceiveUnpossessed",
      "meta": null,
      "args": [
        {
          "name": "OldController",
          "type": "AController"
        }
      ]
    },
    {
      "name": "SetCanAffectNavigationGeneration",
      "return": "void",
      "doc": "Use SetCanAffectNavigationGeneration to change this value at runtime.\nNote that calling this function at runtime will result in any navigation change only if runtime navigation generation is enabled.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "bNewValue",
          "type": "bool"
        },
        {
          "name": "bForceUpdate",
          "default": "false",
          "type": "bool"
        }
      ]
    },
    {
      "name": "SpawnDefaultController",
      "return": "void",
      "doc": "Spawn default controller for this Pawn, and get possessed by it.",
      "ufunction": true,
      "meta": null,
      "args": []
    }
  ]
}