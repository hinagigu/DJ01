{
  "name": "__System",
  "properties": {},
  "methods": [
    {
      "name": "AsyncLineTraceByChannel",
      "return": "FTraceHandle",
      "args": [
        {
          "name": "InTraceType",
          "type": "EAsyncTraceType"
        },
        {
          "name": "Start",
          "type": "FVector"
        },
        {
          "name": "End",
          "type": "FVector"
        },
        {
          "name": "TraceChannel",
          "type": "ECollisionChannel"
        },
        {
          "name": "Params",
          "default": "FCollisionQueryParams :: DefaultQueryParam",
          "type": "FCollisionQueryParams"
        },
        {
          "name": "ResponseParam",
          "default": "FCollisionResponseParams :: DefaultResponseParam",
          "type": "FCollisionResponseParams"
        },
        {
          "name": "InDelegate",
          "default": "FScriptTraceDelegate ( )",
          "type": "FScriptTraceDelegate"
        },
        {
          "name": "UserData",
          "default": "0",
          "type": "uint"
        }
      ]
    },
    {
      "name": "AsyncLineTraceByObjectType",
      "return": "FTraceHandle",
      "args": [
        {
          "name": "InTraceType",
          "type": "EAsyncTraceType"
        },
        {
          "name": "Start",
          "type": "FVector"
        },
        {
          "name": "End",
          "type": "FVector"
        },
        {
          "name": "ObjectQueryParams",
          "type": "FCollisionObjectQueryParams"
        },
        {
          "name": "Params",
          "default": "FCollisionQueryParams :: DefaultQueryParam",
          "type": "FCollisionQueryParams"
        },
        {
          "name": "InDelegate",
          "default": "FScriptTraceDelegate ( )",
          "type": "FScriptTraceDelegate"
        },
        {
          "name": "UserData",
          "default": "0",
          "type": "uint"
        }
      ]
    },
    {
      "name": "AsyncLineTraceByProfile",
      "return": "FTraceHandle",
      "args": [
        {
          "name": "InTraceType",
          "type": "EAsyncTraceType"
        },
        {
          "name": "Start",
          "type": "FVector"
        },
        {
          "name": "End",
          "type": "FVector"
        },
        {
          "name": "ProfileName",
          "type": "FName"
        },
        {
          "name": "Params",
          "default": "FCollisionQueryParams :: DefaultQueryParam",
          "type": "FCollisionQueryParams"
        },
        {
          "name": "InDelegate",
          "default": "FScriptTraceDelegate ( )",
          "type": "FScriptTraceDelegate"
        },
        {
          "name": "UserData",
          "default": "0",
          "type": "uint"
        }
      ]
    },
    {
      "name": "AsyncSweepByChannel",
      "return": "FTraceHandle",
      "args": [
        {
          "name": "InTraceType",
          "type": "EAsyncTraceType"
        },
        {
          "name": "Start",
          "type": "FVector"
        },
        {
          "name": "End",
          "type": "FVector"
        },
        {
          "name": "Rot",
          "type": "FQuat"
        },
        {
          "name": "TraceChannel",
          "type": "ECollisionChannel"
        },
        {
          "name": "CollisionShape",
          "type": "FCollisionShape"
        },
        {
          "name": "Params",
          "default": "FCollisionQueryParams :: DefaultQueryParam",
          "type": "FCollisionQueryParams"
        },
        {
          "name": "ResponseParam",
          "default": "FCollisionResponseParams :: DefaultResponseParam",
          "type": "FCollisionResponseParams"
        },
        {
          "name": "InDelegate",
          "default": "FScriptTraceDelegate ( )",
          "type": "FScriptTraceDelegate"
        },
        {
          "name": "UserData",
          "default": "0",
          "type": "uint"
        }
      ]
    },
    {
      "name": "AsyncSweepByObjectType",
      "return": "FTraceHandle",
      "args": [
        {
          "name": "InTraceType",
          "type": "EAsyncTraceType"
        },
        {
          "name": "Start",
          "type": "FVector"
        },
        {
          "name": "End",
          "type": "FVector"
        },
        {
          "name": "Rot",
          "type": "FQuat"
        },
        {
          "name": "ObjectQueryParams",
          "type": "FCollisionObjectQueryParams"
        },
        {
          "name": "CollisionShape",
          "type": "FCollisionShape"
        },
        {
          "name": "Params",
          "default": "FCollisionQueryParams :: DefaultQueryParam",
          "type": "FCollisionQueryParams"
        },
        {
          "name": "InDelegate",
          "default": "FScriptTraceDelegate ( )",
          "type": "FScriptTraceDelegate"
        },
        {
          "name": "UserData",
          "default": "0",
          "type": "uint"
        }
      ]
    },
    {
      "name": "AsyncSweepByProfile",
      "return": "FTraceHandle",
      "args": [
        {
          "name": "InTraceType",
          "type": "EAsyncTraceType"
        },
        {
          "name": "Start",
          "type": "FVector"
        },
        {
          "name": "End",
          "type": "FVector"
        },
        {
          "name": "Rot",
          "type": "FQuat"
        },
        {
          "name": "ProfileName",
          "type": "FName"
        },
        {
          "name": "CollisionShape",
          "type": "FCollisionShape"
        },
        {
          "name": "Params",
          "default": "FCollisionQueryParams :: DefaultQueryParam",
          "type": "FCollisionQueryParams"
        },
        {
          "name": "InDelegate",
          "default": "FScriptTraceDelegate ( )",
          "type": "FScriptTraceDelegate"
        },
        {
          "name": "UserData",
          "default": "0",
          "type": "uint"
        }
      ]
    },
    {
      "name": "AsyncOverlapByChannel",
      "return": "FTraceHandle",
      "args": [
        {
          "name": "Pos",
          "type": "FVector"
        },
        {
          "name": "Rot",
          "type": "FQuat"
        },
        {
          "name": "TraceChannel",
          "type": "ECollisionChannel"
        },
        {
          "name": "CollisionShape",
          "type": "FCollisionShape"
        },
        {
          "name": "Params",
          "default": "FCollisionQueryParams :: DefaultQueryParam",
          "type": "FCollisionQueryParams"
        },
        {
          "name": "ResponseParam",
          "default": "FCollisionResponseParams :: DefaultResponseParam",
          "type": "FCollisionResponseParams"
        },
        {
          "name": "InDelegate",
          "default": "FScriptOverlapDelegate ( )",
          "type": "FScriptOverlapDelegate"
        },
        {
          "name": "UserData",
          "default": "0",
          "type": "uint"
        }
      ]
    },
    {
      "name": "AsyncOverlapByObjectType",
      "return": "FTraceHandle",
      "args": [
        {
          "name": "Pos",
          "type": "FVector"
        },
        {
          "name": "Rot",
          "type": "FQuat"
        },
        {
          "name": "ObjectQueryParams",
          "type": "FCollisionObjectQueryParams"
        },
        {
          "name": "CollisionShape",
          "type": "FCollisionShape"
        },
        {
          "name": "Params",
          "default": "FCollisionQueryParams :: DefaultQueryParam",
          "type": "FCollisionQueryParams"
        },
        {
          "name": "InDelegate",
          "default": "FScriptOverlapDelegate ( )",
          "type": "FScriptOverlapDelegate"
        },
        {
          "name": "UserData",
          "default": "0",
          "type": "uint"
        }
      ]
    },
    {
      "name": "QueryTraceData",
      "return": "bool",
      "args": [
        {
          "name": "Handle",
          "type": "FTraceHandle"
        },
        {
          "name": "OutData",
          "type": "FTraceDatum&"
        }
      ]
    },
    {
      "name": "QueryOverlapData",
      "return": "bool",
      "args": [
        {
          "name": "Handle",
          "type": "FTraceHandle"
        },
        {
          "name": "OutData",
          "type": "FOverlapDatum&"
        }
      ]
    },
    {
      "name": "IsTraceHandleValid",
      "return": "bool",
      "args": [
        {
          "name": "Handle",
          "type": "FTraceHandle"
        },
        {
          "name": "bOverlapTrace",
          "type": "bool"
        }
      ]
    },
    {
      "name": "AddFloatHistorySample",
      "return": "FDebugFloatHistory",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Value",
          "type": "float32"
        },
        {
          "name": "FloatHistory",
          "type": "FDebugFloatHistory"
        }
      ]
    },
    {
      "name": "BeginTransaction",
      "return": "int",
      "doc": "Begin a new undo transaction. An undo transaction is defined as all actions which take place when the user selects \"undo\" a single time.\n@note If there is already an active transaction in progress, then this increments that transaction's action counter instead of beginning a new transaction.\n@note You must call TransactObject before modifying each object that should be included in this undo transaction.\n@note Only available in the editor.\n\n@param       Context                 The context for the undo session. Typically the tool/editor that caused the undo operation.\n@param       Description             The description for the undo session. This is the text that will appear in the \"Edit\" menu next to the Undo item.\n@param       PrimaryObject   The primary object that the undo session operators on (can be null, and mostly is).\n\n@return      The number of active actions when BeginTransaction was called (values greater than 0 indicate that there was already an existing undo transaction in progress), or -1 on failure.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Context",
          "type": "FString"
        },
        {
          "name": "Description",
          "type": "FText"
        },
        {
          "name": "PrimaryObject",
          "type": "UObject"
        }
      ]
    },
    {
      "name": "BoxOverlapActors",
      "return": "bool",
      "doc": "Returns an array of actors that overlap the given axis-aligned box.\n@param WorldContext  World context\n@param BoxPos                Center of box.\n@param BoxExtent             Extents of box.\n@param Filter                Option to restrict results to only static or only dynamic.  For efficiency.\n@param ClassFilter   If set, will only return results of this class or subclasses of it.\n@param ActorsToIgnore                Ignore these actors in the list\n@param OutActors             Returned array of actors. Unsorted.\n@return                              true if there was an overlap that passed the filters, false otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "BoxPos",
          "type": "FVector"
        },
        {
          "name": "BoxExtent",
          "type": "FVector"
        },
        {
          "name": "ObjectTypes",
          "type": "TArray<EObjectTypeQuery>"
        },
        {
          "name": "ActorClassFilter",
          "type": "UClass"
        },
        {
          "name": "ActorsToIgnore",
          "type": "TArray<AActor>"
        },
        {
          "name": "OutActors",
          "type": "TArray<AActor>&"
        }
      ]
    },
    {
      "name": "BoxOverlapComponents",
      "return": "bool",
      "doc": "Returns an array of components that overlap the given axis-aligned box.\n@param WorldContext  World context\n@param BoxPos                Center of box.\n@param BoxExtent             Extents of box.\n@param Filter                Option to restrict results to only static or only dynamic.  For efficiency.\n@param ClassFilter   If set, will only return results of this class or subclasses of it.\n@param ActorsToIgnore                Ignore these actors in the list\n@param OutActors             Returned array of actors. Unsorted.\n@return                              true if there was an overlap that passed the filters, false otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "BoxPos",
          "type": "FVector"
        },
        {
          "name": "Extent",
          "type": "FVector"
        },
        {
          "name": "ObjectTypes",
          "type": "TArray<EObjectTypeQuery>"
        },
        {
          "name": "ComponentClassFilter",
          "type": "UClass"
        },
        {
          "name": "ActorsToIgnore",
          "type": "TArray<AActor>"
        },
        {
          "name": "OutComponents",
          "type": "TArray<UPrimitiveComponent>&"
        }
      ]
    },
    {
      "name": "BoxTraceMulti",
      "return": "bool",
      "doc": "Sweeps a box along the given line and returns all hits encountered.\nThis trace finds the objects that RESPONDS to the given TraceChannel\n\n@param Start                  Start of line segment.\n@param End                    End of line segment.\n@param HalfSize           Distance from the center of box along each axis\n@param Orientation    Orientation of the box\n@param TraceChannel\n@param bTraceComplex  True to test against complex collision, false to test against simplified collision.\n@param OutHits                A list of hits, sorted along the trace from start to finish. The blocking hit will be the last hit, if there was one.\n@return                               True if there was a blocking hit, false otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Start",
          "type": "FVector"
        },
        {
          "name": "End",
          "type": "FVector"
        },
        {
          "name": "HalfSize",
          "type": "FVector"
        },
        {
          "name": "Orientation",
          "type": "FRotator"
        },
        {
          "name": "TraceChannel",
          "type": "ETraceTypeQuery"
        },
        {
          "name": "bTraceComplex",
          "type": "bool"
        },
        {
          "name": "ActorsToIgnore",
          "type": "TArray<AActor>"
        },
        {
          "name": "DrawDebugType",
          "type": "EDrawDebugTrace"
        },
        {
          "name": "OutHits",
          "type": "TArray<FHitResult>&"
        },
        {
          "name": "bIgnoreSelf",
          "type": "bool"
        },
        {
          "name": "TraceColor",
          "default": "FLinearColor ( 1.000000 , 0.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "TraceHitColor",
          "default": "FLinearColor ( 0.000000 , 1.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "DrawTime",
          "default": "5.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "BoxTraceMultiByProfile",
      "return": "bool",
      "doc": "Sweep a box against the world and return all initial overlaps using a specific profile, then overlapping hits and then first blocking hit\nResults are sorted, so a blocking hit (if found) will be the last element of the array\nOnly the single closest blocking result will be generated, no tests will be done after that\n\n@param Start                  Start of line segment.\n@param End                    End of line segment.\n@param HalfSize           Distance from the center of box along each axis\n@param Orientation    Orientation of the box\n@param ProfileName    The 'profile' used to determine which components to hit\n@param bTraceComplex  True to test against complex collision, false to test against simplified collision.\n@param OutHits                A list of hits, sorted along the trace from start to finish. The blocking hit will be the last hit, if there was one.\n@return                               True if there was a blocking hit, false otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Start",
          "type": "FVector"
        },
        {
          "name": "End",
          "type": "FVector"
        },
        {
          "name": "HalfSize",
          "type": "FVector"
        },
        {
          "name": "Orientation",
          "type": "FRotator"
        },
        {
          "name": "ProfileName",
          "type": "FName"
        },
        {
          "name": "bTraceComplex",
          "type": "bool"
        },
        {
          "name": "ActorsToIgnore",
          "type": "TArray<AActor>"
        },
        {
          "name": "DrawDebugType",
          "type": "EDrawDebugTrace"
        },
        {
          "name": "OutHits",
          "type": "TArray<FHitResult>&"
        },
        {
          "name": "bIgnoreSelf",
          "type": "bool"
        },
        {
          "name": "TraceColor",
          "default": "FLinearColor ( 1.000000 , 0.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "TraceHitColor",
          "default": "FLinearColor ( 0.000000 , 1.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "DrawTime",
          "default": "5.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "BoxTraceMultiForObjects",
      "return": "bool",
      "doc": "Sweeps a box along the given line and returns all hits encountered.\nThis only finds objects that are of a type specified by ObjectTypes.\n\n@param Start                  Start of line segment.\n@param End                    End of line segment.\n@param Orientation\n@param HalfSize               Radius of the sphere to sweep\n@param ObjectTypes    Array of Object Types to trace\n@param bTraceComplex  True to test against complex collision, false to test against simplified collision.\n@param OutHits                A list of hits, sorted along the trace from start to finish.  The blocking hit will be the last hit, if there was one.\n@return                               True if there was a hit, false otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Start",
          "type": "FVector"
        },
        {
          "name": "End",
          "type": "FVector"
        },
        {
          "name": "HalfSize",
          "type": "FVector"
        },
        {
          "name": "Orientation",
          "type": "FRotator"
        },
        {
          "name": "ObjectTypes",
          "type": "TArray<EObjectTypeQuery>"
        },
        {
          "name": "bTraceComplex",
          "type": "bool"
        },
        {
          "name": "ActorsToIgnore",
          "type": "TArray<AActor>"
        },
        {
          "name": "DrawDebugType",
          "type": "EDrawDebugTrace"
        },
        {
          "name": "OutHits",
          "type": "TArray<FHitResult>&"
        },
        {
          "name": "bIgnoreSelf",
          "type": "bool"
        },
        {
          "name": "TraceColor",
          "default": "FLinearColor ( 1.000000 , 0.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "TraceHitColor",
          "default": "FLinearColor ( 0.000000 , 1.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "DrawTime",
          "default": "5.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "BoxTraceSingle",
      "return": "bool",
      "doc": "Sweeps a box along the given line and returns the first blocking hit encountered.\nThis trace finds the objects that RESPONDS to the given TraceChannel\n\n@param Start                  Start of line segment.\n@param End                    End of line segment.\n@param HalfSize           Distance from the center of box along each axis\n@param Orientation    Orientation of the box\n@param TraceChannel\n@param bTraceComplex  True to test against complex collision, false to test against simplified collision.\n@param OutHit                 Properties of the trace hit.\n@return                               True if there was a hit, false otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Start",
          "type": "FVector"
        },
        {
          "name": "End",
          "type": "FVector"
        },
        {
          "name": "HalfSize",
          "type": "FVector"
        },
        {
          "name": "Orientation",
          "type": "FRotator"
        },
        {
          "name": "TraceChannel",
          "type": "ETraceTypeQuery"
        },
        {
          "name": "bTraceComplex",
          "type": "bool"
        },
        {
          "name": "ActorsToIgnore",
          "type": "TArray<AActor>"
        },
        {
          "name": "DrawDebugType",
          "type": "EDrawDebugTrace"
        },
        {
          "name": "OutHit",
          "type": "FHitResult&"
        },
        {
          "name": "bIgnoreSelf",
          "type": "bool"
        },
        {
          "name": "TraceColor",
          "default": "FLinearColor ( 1.000000 , 0.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "TraceHitColor",
          "default": "FLinearColor ( 0.000000 , 1.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "DrawTime",
          "default": "5.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "BoxTraceSingleByProfile",
      "return": "bool",
      "doc": "Sweep a box against the world and return the first blocking hit using a specific profile\n\n@param Start                  Start of line segment.\n@param End                    End of line segment.\n@param HalfSize           Distance from the center of box along each axis\n@param Orientation    Orientation of the box\n@param ProfileName    The 'profile' used to determine which components to hit\n@param bTraceComplex  True to test against complex collision, false to test against simplified collision.\n@param OutHit                 Properties of the trace hit.\n@return                               True if there was a hit, false otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Start",
          "type": "FVector"
        },
        {
          "name": "End",
          "type": "FVector"
        },
        {
          "name": "HalfSize",
          "type": "FVector"
        },
        {
          "name": "Orientation",
          "type": "FRotator"
        },
        {
          "name": "ProfileName",
          "type": "FName"
        },
        {
          "name": "bTraceComplex",
          "type": "bool"
        },
        {
          "name": "ActorsToIgnore",
          "type": "TArray<AActor>"
        },
        {
          "name": "DrawDebugType",
          "type": "EDrawDebugTrace"
        },
        {
          "name": "OutHit",
          "type": "FHitResult&"
        },
        {
          "name": "bIgnoreSelf",
          "type": "bool"
        },
        {
          "name": "TraceColor",
          "default": "FLinearColor ( 1.000000 , 0.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "TraceHitColor",
          "default": "FLinearColor ( 0.000000 , 1.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "DrawTime",
          "default": "5.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "BoxTraceSingleForObjects",
      "return": "bool",
      "doc": "Sweeps a box along the given line and returns the first hit encountered.\nThis only finds objects that are of a type specified by ObjectTypes.\n\n@param Start                  Start of line segment.\n@param End                    End of line segment.\n@param Orientation\n@param HalfSize               Radius of the sphere to sweep\n@param ObjectTypes    Array of Object Types to trace\n@param bTraceComplex  True to test against complex collision, false to test against simplified collision.\n@param OutHit                 Properties of the trace hit.\n@return                               True if there was a hit, false otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Start",
          "type": "FVector"
        },
        {
          "name": "End",
          "type": "FVector"
        },
        {
          "name": "HalfSize",
          "type": "FVector"
        },
        {
          "name": "Orientation",
          "type": "FRotator"
        },
        {
          "name": "ObjectTypes",
          "type": "TArray<EObjectTypeQuery>"
        },
        {
          "name": "bTraceComplex",
          "type": "bool"
        },
        {
          "name": "ActorsToIgnore",
          "type": "TArray<AActor>"
        },
        {
          "name": "DrawDebugType",
          "type": "EDrawDebugTrace"
        },
        {
          "name": "OutHit",
          "type": "FHitResult&"
        },
        {
          "name": "bIgnoreSelf",
          "type": "bool"
        },
        {
          "name": "TraceColor",
          "default": "FLinearColor ( 1.000000 , 0.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "TraceHitColor",
          "default": "FLinearColor ( 0.000000 , 1.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "DrawTime",
          "default": "5.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "BreakARFilter",
      "return": "void",
      "doc": "Breaks an ARFilter struct into its component pieces. You should be using ClassPaths and RecursiveClassPathsExclusionSet from this node, ClassNames and RecursiveClassesExclusionSet are deprecated.\n\n@param ClassNames [DEPRECATED] - Class names are now represented by path names. Please use the ClassPaths output instead.\n@param RecursiveClassesExclusionSet [DEPRECATED] - Class names are now represented by path names. Please use the RecursiveClassPathsExclusionSet output instead.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "InARFilter",
          "type": "FARFilter"
        },
        {
          "name": "PackageNames",
          "type": "TArray<FName>&"
        },
        {
          "name": "PackagePaths",
          "type": "TArray<FName>&"
        },
        {
          "name": "SoftObjectPaths",
          "type": "TArray<FSoftObjectPath>&"
        },
        {
          "name": "ClassPaths",
          "type": "TArray<FTopLevelAssetPath>&"
        },
        {
          "name": "RecursiveClassPathsExclusionSet",
          "type": "TSet<FTopLevelAssetPath>&"
        },
        {
          "name": "ClassNames",
          "type": "TArray<FName>&"
        },
        {
          "name": "RecursiveClassesExclusionSet",
          "type": "TSet<FName>&"
        },
        {
          "name": "bRecursivePaths",
          "type": "bool&"
        },
        {
          "name": "bRecursiveClasses",
          "type": "bool&"
        },
        {
          "name": "bIncludeOnlyOnDiskAssets",
          "type": "bool&"
        }
      ]
    },
    {
      "name": "BreakSoftClassPath",
      "return": "void",
      "doc": "Gets the path string out of a Soft Class Path",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "InSoftClassPath",
          "type": "FSoftClassPath"
        },
        {
          "name": "PathString",
          "type": "FString&"
        }
      ]
    },
    {
      "name": "BreakSoftObjectPath",
      "return": "void",
      "doc": "Gets the path string out of a Soft Object Path",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "InSoftObjectPath",
          "type": "FSoftObjectPath"
        },
        {
          "name": "PathString",
          "type": "FString&"
        }
      ]
    },
    {
      "name": "BreakTopLevelAssetPath",
      "return": "void",
      "doc": "Gets the path string out of a TopLevelAssetPath",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "TopLevelAssetPath",
          "type": "FTopLevelAssetPath"
        },
        {
          "name": "PathString",
          "type": "FString&"
        }
      ]
    },
    {
      "name": "CancelTransaction",
      "return": "void",
      "doc": "Cancel the current transaction, and no longer capture actions to be placed in the undo buffer.\n@note Only available in the editor.\n\n@param       Index           The action counter to cancel transactions from (as returned by a call to BeginTransaction).",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Index",
          "type": "int"
        }
      ]
    },
    {
      "name": "CanLaunchURL",
      "return": "bool",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "URL",
          "type": "FString"
        }
      ]
    },
    {
      "name": "CapsuleOverlapActors",
      "return": "bool",
      "doc": "Returns an array of actors that overlap the given capsule.\n@param WorldContext  World context\n@param CapsulePos    Center of the capsule.\n@param Radius                Radius of capsule hemispheres and radius of center cylinder portion.\n@param HalfHeight    Half-height of the capsule (from center of capsule to tip of hemisphere.\n@param Filter                Option to restrict results to only static or only dynamic.  For efficiency.\n@param ClassFilter   If set, will only return results of this class or subclasses of it.\n@param ActorsToIgnore                Ignore these actors in the list\n@param OutActors             Returned array of actors. Unsorted.\n@return                              true if there was an overlap that passed the filters, false otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "CapsulePos",
          "type": "FVector"
        },
        {
          "name": "Radius",
          "type": "float32"
        },
        {
          "name": "HalfHeight",
          "type": "float32"
        },
        {
          "name": "ObjectTypes",
          "type": "TArray<EObjectTypeQuery>"
        },
        {
          "name": "ActorClassFilter",
          "type": "UClass"
        },
        {
          "name": "ActorsToIgnore",
          "type": "TArray<AActor>"
        },
        {
          "name": "OutActors",
          "type": "TArray<AActor>&"
        }
      ]
    },
    {
      "name": "CapsuleOverlapComponents",
      "return": "bool",
      "doc": "Returns an array of components that overlap the given capsule.\n@param WorldContext  World context\n@param CapsulePos    Center of the capsule.\n@param Radius                Radius of capsule hemispheres and radius of center cylinder portion.\n@param HalfHeight    Half-height of the capsule (from center of capsule to tip of hemisphere.\n@param Filter                Option to restrict results to only static or only dynamic.  For efficiency.\n@param ClassFilter   If set, will only return results of this class or subclasses of it.\n@param ActorsToIgnore                Ignore these actors in the list\n@param OutActors             Returned array of actors. Unsorted.\n@return                              true if there was an overlap that passed the filters, false otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "CapsulePos",
          "type": "FVector"
        },
        {
          "name": "Radius",
          "type": "float32"
        },
        {
          "name": "HalfHeight",
          "type": "float32"
        },
        {
          "name": "ObjectTypes",
          "type": "TArray<EObjectTypeQuery>"
        },
        {
          "name": "ComponentClassFilter",
          "type": "UClass"
        },
        {
          "name": "ActorsToIgnore",
          "type": "TArray<AActor>"
        },
        {
          "name": "OutComponents",
          "type": "TArray<UPrimitiveComponent>&"
        }
      ]
    },
    {
      "name": "CapsuleTraceMulti",
      "return": "bool",
      "doc": "Sweeps a capsule along the given line and returns all hits encountered up to and including the first blocking hit.\nThis trace finds the objects that RESPOND to the given TraceChannel\n\n@param WorldContext  World context\n@param Start                 Start of line segment.\n@param End                   End of line segment.\n@param Radius                Radius of the capsule to sweep\n@param HalfHeight    Distance from center of capsule to tip of hemisphere endcap.\n@param TraceChannel\n@param bTraceComplex True to test against complex collision, false to test against simplified collision.\n@param OutHits               A list of hits, sorted along the trace from start to finish.  The blocking hit will be the last hit, if there was one.\n@return                              True if there was a blocking hit, false otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Start",
          "type": "FVector"
        },
        {
          "name": "End",
          "type": "FVector"
        },
        {
          "name": "Radius",
          "type": "float32"
        },
        {
          "name": "HalfHeight",
          "type": "float32"
        },
        {
          "name": "TraceChannel",
          "type": "ETraceTypeQuery"
        },
        {
          "name": "bTraceComplex",
          "type": "bool"
        },
        {
          "name": "ActorsToIgnore",
          "type": "TArray<AActor>"
        },
        {
          "name": "DrawDebugType",
          "type": "EDrawDebugTrace"
        },
        {
          "name": "OutHits",
          "type": "TArray<FHitResult>&"
        },
        {
          "name": "bIgnoreSelf",
          "type": "bool"
        },
        {
          "name": "TraceColor",
          "default": "FLinearColor ( 1.000000 , 0.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "TraceHitColor",
          "default": "FLinearColor ( 0.000000 , 1.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "DrawTime",
          "default": "5.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "CapsuleTraceMultiByProfile",
      "return": "bool",
      "doc": "Sweep a capsule against the world and return all initial overlaps using a specific profile, then overlapping hits and then first blocking hit\nResults are sorted, so a blocking hit (if found) will be the last element of the array\nOnly the single closest blocking result will be generated, no tests will be done after that\n\n@param WorldContext   World context\n@param Start                  Start of line segment.\n@param End                    End of line segment.\n@param Radius                 Radius of the capsule to sweep\n@param HalfHeight             Distance from center of capsule to tip of hemisphere endcap.\n@param ProfileName    The 'profile' used to determine which components to hit\n@param bTraceComplex  True to test against complex collision, false to test against simplified collision.\n@param OutHits                A list of hits, sorted along the trace from start to finish.  The blocking hit will be the last hit, if there was one.\n@return                               True if there was a blocking hit, false otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Start",
          "type": "FVector"
        },
        {
          "name": "End",
          "type": "FVector"
        },
        {
          "name": "Radius",
          "type": "float32"
        },
        {
          "name": "HalfHeight",
          "type": "float32"
        },
        {
          "name": "ProfileName",
          "type": "FName"
        },
        {
          "name": "bTraceComplex",
          "type": "bool"
        },
        {
          "name": "ActorsToIgnore",
          "type": "TArray<AActor>"
        },
        {
          "name": "DrawDebugType",
          "type": "EDrawDebugTrace"
        },
        {
          "name": "OutHits",
          "type": "TArray<FHitResult>&"
        },
        {
          "name": "bIgnoreSelf",
          "type": "bool"
        },
        {
          "name": "TraceColor",
          "default": "FLinearColor ( 1.000000 , 0.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "TraceHitColor",
          "default": "FLinearColor ( 0.000000 , 1.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "DrawTime",
          "default": "5.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "CapsuleTraceMultiForObjects",
      "return": "bool",
      "doc": "Sweeps a capsule along the given line and returns all hits encountered.\nThis only finds objects that are of a type specified by ObjectTypes.\n\n@param WorldContext  World context\n@param Start                 Start of line segment.\n@param End                   End of line segment.\n@param Radius                Radius of the capsule to sweep\n@param HalfHeight    Distance from center of capsule to tip of hemisphere endcap.\n@param ObjectTypes   Array of Object Types to trace\n@param bTraceComplex True to test against complex collision, false to test against simplified collision.\n@param OutHits               A list of hits, sorted along the trace from start to finish.  The blocking hit will be the last hit, if there was one.\n@return                              True if there was a hit, false otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Start",
          "type": "FVector"
        },
        {
          "name": "End",
          "type": "FVector"
        },
        {
          "name": "Radius",
          "type": "float32"
        },
        {
          "name": "HalfHeight",
          "type": "float32"
        },
        {
          "name": "ObjectTypes",
          "type": "TArray<EObjectTypeQuery>"
        },
        {
          "name": "bTraceComplex",
          "type": "bool"
        },
        {
          "name": "ActorsToIgnore",
          "type": "TArray<AActor>"
        },
        {
          "name": "DrawDebugType",
          "type": "EDrawDebugTrace"
        },
        {
          "name": "OutHits",
          "type": "TArray<FHitResult>&"
        },
        {
          "name": "bIgnoreSelf",
          "type": "bool"
        },
        {
          "name": "TraceColor",
          "default": "FLinearColor ( 1.000000 , 0.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "TraceHitColor",
          "default": "FLinearColor ( 0.000000 , 1.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "DrawTime",
          "default": "5.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "CapsuleTraceSingle",
      "return": "bool",
      "doc": "Sweeps a capsule along the given line and returns the first blocking hit encountered.\nThis trace finds the objects that RESPOND to the given TraceChannel\n\n@param WorldContext  World context\n@param Start                 Start of line segment.\n@param End                   End of line segment.\n@param Radius                Radius of the capsule to sweep\n@param HalfHeight    Distance from center of capsule to tip of hemisphere endcap.\n@param TraceChannel\n@param bTraceComplex True to test against complex collision, false to test against simplified collision.\n@param OutHit                Properties of the trace hit.\n@return                              True if there was a hit, false otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Start",
          "type": "FVector"
        },
        {
          "name": "End",
          "type": "FVector"
        },
        {
          "name": "Radius",
          "type": "float32"
        },
        {
          "name": "HalfHeight",
          "type": "float32"
        },
        {
          "name": "TraceChannel",
          "type": "ETraceTypeQuery"
        },
        {
          "name": "bTraceComplex",
          "type": "bool"
        },
        {
          "name": "ActorsToIgnore",
          "type": "TArray<AActor>"
        },
        {
          "name": "DrawDebugType",
          "type": "EDrawDebugTrace"
        },
        {
          "name": "OutHit",
          "type": "FHitResult&"
        },
        {
          "name": "bIgnoreSelf",
          "type": "bool"
        },
        {
          "name": "TraceColor",
          "default": "FLinearColor ( 1.000000 , 0.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "TraceHitColor",
          "default": "FLinearColor ( 0.000000 , 1.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "DrawTime",
          "default": "5.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "CapsuleTraceSingleByProfile",
      "return": "bool",
      "doc": "Sweep a capsule against the world and return the first blocking hit using a specific profile\n\n@param WorldContext   World context\n@param Start                  Start of line segment.\n@param End                    End of line segment.\n@param Radius                 Radius of the capsule to sweep\n@param HalfHeight             Distance from center of capsule to tip of hemisphere endcap.\n@param ProfileName    The 'profile' used to determine which components to hit\n@param bTraceComplex  True to test against complex collision, false to test against simplified collision.\n@param OutHit                 Properties of the trace hit.\n@return                               True if there was a hit, false otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Start",
          "type": "FVector"
        },
        {
          "name": "End",
          "type": "FVector"
        },
        {
          "name": "Radius",
          "type": "float32"
        },
        {
          "name": "HalfHeight",
          "type": "float32"
        },
        {
          "name": "ProfileName",
          "type": "FName"
        },
        {
          "name": "bTraceComplex",
          "type": "bool"
        },
        {
          "name": "ActorsToIgnore",
          "type": "TArray<AActor>"
        },
        {
          "name": "DrawDebugType",
          "type": "EDrawDebugTrace"
        },
        {
          "name": "OutHit",
          "type": "FHitResult&"
        },
        {
          "name": "bIgnoreSelf",
          "type": "bool"
        },
        {
          "name": "TraceColor",
          "default": "FLinearColor ( 1.000000 , 0.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "TraceHitColor",
          "default": "FLinearColor ( 0.000000 , 1.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "DrawTime",
          "default": "5.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "CapsuleTraceSingleForObjects",
      "return": "bool",
      "doc": "Sweeps a capsule along the given line and returns the first hit encountered.\nThis only finds objects that are of a type specified by ObjectTypes.\n\n@param WorldContext  World context\n@param Start                 Start of line segment.\n@param End                   End of line segment.\n@param Radius                Radius of the capsule to sweep\n@param HalfHeight    Distance from center of capsule to tip of hemisphere endcap.\n@param ObjectTypes   Array of Object Types to trace\n@param bTraceComplex True to test against complex collision, false to test against simplified collision.\n@param OutHit                Properties of the trace hit.\n@return                              True if there was a hit, false otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Start",
          "type": "FVector"
        },
        {
          "name": "End",
          "type": "FVector"
        },
        {
          "name": "Radius",
          "type": "float32"
        },
        {
          "name": "HalfHeight",
          "type": "float32"
        },
        {
          "name": "ObjectTypes",
          "type": "TArray<EObjectTypeQuery>"
        },
        {
          "name": "bTraceComplex",
          "type": "bool"
        },
        {
          "name": "ActorsToIgnore",
          "type": "TArray<AActor>"
        },
        {
          "name": "DrawDebugType",
          "type": "EDrawDebugTrace"
        },
        {
          "name": "OutHit",
          "type": "FHitResult&"
        },
        {
          "name": "bIgnoreSelf",
          "type": "bool"
        },
        {
          "name": "TraceColor",
          "default": "FLinearColor ( 1.000000 , 0.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "TraceHitColor",
          "default": "FLinearColor ( 0.000000 , 1.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "DrawTime",
          "default": "5.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "CollectGarbage",
      "return": "void",
      "doc": "Deletes all unreferenced objects, keeping only referenced objects (this command will be queued and happen at the end of the frame)\nNote: This can be a slow operation, and should only be performed where a hitch would be acceptable",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "ComponentOverlapActors",
      "return": "bool",
      "doc": "Returns an array of actors that overlap the given component.\n@param Component                             Component to test with.\n@param ComponentTransform    Defines where to place the component for overlap testing.\n@param Filter                                Option to restrict results to only static or only dynamic.  For efficiency.\n@param ClassFilter                   If set, will only return results of this class or subclasses of it.\n@param ActorsToIgnore                Ignore these actors in the list\n@param OutActors                             Returned array of actors. Unsorted.\n@return                                              true if there was an overlap that passed the filters, false otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Component",
          "type": "UPrimitiveComponent"
        },
        {
          "name": "ComponentTransform",
          "type": "FTransform"
        },
        {
          "name": "ObjectTypes",
          "type": "TArray<EObjectTypeQuery>"
        },
        {
          "name": "ActorClassFilter",
          "type": "UClass"
        },
        {
          "name": "ActorsToIgnore",
          "type": "TArray<AActor>"
        },
        {
          "name": "OutActors",
          "type": "TArray<AActor>&"
        }
      ]
    },
    {
      "name": "ComponentOverlapComponents",
      "return": "bool",
      "doc": "Returns an array of components that overlap the given component.\n@param Component                             Component to test with.\n@param ComponentTransform    Defines where to place the component for overlap testing.\n@param Filter                                Option to restrict results to only static or only dynamic.  For efficiency.\n@param ClassFilter                   If set, will only return results of this class or subclasses of it.\n@param ActorsToIgnore                Ignore these actors in the list\n@param OutActors                             Returned array of actors. Unsorted.\n@return                                              true if there was an overlap that passed the filters, false otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Component",
          "type": "UPrimitiveComponent"
        },
        {
          "name": "ComponentTransform",
          "type": "FTransform"
        },
        {
          "name": "ObjectTypes",
          "type": "TArray<EObjectTypeQuery>"
        },
        {
          "name": "ComponentClassFilter",
          "type": "UClass"
        },
        {
          "name": "ActorsToIgnore",
          "type": "TArray<AActor>"
        },
        {
          "name": "OutComponents",
          "type": "TArray<UPrimitiveComponent>&"
        }
      ]
    },
    {
      "name": "ControlScreensaver",
      "return": "void",
      "doc": "Allows or inhibits screensaver\n@param       bAllowScreenSaver               If false, don't allow screensaver if possible, otherwise allow default behavior",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "bAllowScreenSaver",
          "type": "bool"
        }
      ]
    },
    {
      "name": "Conv_ComponentReferenceToSoftComponentReference",
      "return": "FSoftComponentReference",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "ComponentReference",
          "type": "FComponentReference"
        }
      ]
    },
    {
      "name": "Conv_ObjectToClass",
      "return": "UClass",
      "doc": "Casts from an object to a class, this will only work if the object is already a class",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Object",
          "type": "UObject"
        },
        {
          "name": "Class",
          "type": "TSubclassOf<UObject>"
        }
      ],
      "outputTypeIndex": 1
    },
    {
      "name": "Conv_PrimaryAssetIdToString",
      "return": "FString",
      "doc": "Converts a Primary Asset Id to a string. The other direction is not provided because it cannot be validated",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "PrimaryAssetId",
          "type": "FPrimaryAssetId"
        }
      ]
    },
    {
      "name": "Conv_PrimaryAssetTypeToString",
      "return": "FString",
      "doc": "Converts a Primary Asset Type to a string. The other direction is not provided because it cannot be validated",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "PrimaryAssetType",
          "type": "FPrimaryAssetType"
        }
      ]
    },
    {
      "name": "Conv_SoftClassPathToSoftClassRef",
      "return": "TSoftClassPtr<UObject>",
      "doc": "Converts a Soft Class Path into a base Soft Class Reference, this is not guaranteed to be resolvable",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "SoftClassPath",
          "type": "FSoftClassPath"
        }
      ]
    },
    {
      "name": "Conv_SoftClassReferenceToString",
      "return": "FString",
      "doc": "Converts a Soft Class Reference to a path string",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "SoftClassReference",
          "type": "TSoftClassPtr<UObject>"
        }
      ]
    },
    {
      "name": "Conv_SoftObjectReferenceToString",
      "return": "FString",
      "doc": "Converts a Soft Object Reference to a path string",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "SoftObjectReference",
          "type": "TSoftObjectPtr<UObject>"
        }
      ]
    },
    {
      "name": "Conv_SoftObjPathToSoftObjRef",
      "return": "TSoftObjectPtr<UObject>",
      "doc": "Converts a Soft Object Path into a base Soft Object Reference, this is not guaranteed to be resolvable",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "SoftObjectPath",
          "type": "FSoftObjectPath"
        }
      ]
    },
    {
      "name": "Conv_SoftObjRefToSoftClassPath",
      "return": "FSoftClassPath",
      "doc": "Converts a Soft Class Reference into a Soft Class Path (which can be used like a Soft Object Path)",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "SoftClassReference",
          "type": "TSoftClassPtr<UObject>"
        }
      ]
    },
    {
      "name": "Conv_SoftObjRefToSoftObjPath",
      "return": "FSoftObjectPath",
      "doc": "Converts a Soft Object Reference into a Soft Object Path",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "SoftObjectReference",
          "type": "TSoftObjectPtr<UObject>"
        }
      ]
    },
    {
      "name": "ConvertToAbsolutePath",
      "return": "FString",
      "doc": "Converts passed in filename to use a absolute path",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Filename",
          "type": "FString"
        }
      ]
    },
    {
      "name": "ConvertToRelativePath",
      "return": "FString",
      "doc": "Converts passed in filename to use a relative path",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Filename",
          "type": "FString"
        }
      ]
    },
    {
      "name": "CreateCopyForUndoBuffer",
      "return": "void",
      "doc": "Mark as modified.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "ObjectToModify",
          "type": "UObject"
        }
      ]
    },
    {
      "name": "Delay",
      "return": "void",
      "doc": "Perform a latent action with a delay (specified in seconds).  Calling again while it is counting down will be ignored.\n\n@param WorldContext  World context.\n@param Duration              length of delay (in seconds).\n@param LatentInfo    The latent action.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Duration",
          "type": "float32"
        },
        {
          "name": "LatentInfo",
          "type": "FLatentActionInfo"
        }
      ]
    },
    {
      "name": "DelayUntilNextTick",
      "return": "void",
      "doc": "Perform a latent action with a delay of one tick.  Calling again while it is counting down will be ignored.\n\n@param WorldContext  World context.\n@param LatentInfo    The latent action.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "LatentInfo",
          "type": "FLatentActionInfo"
        }
      ]
    },
    {
      "name": "DoesClassImplementInterface",
      "return": "bool",
      "doc": "Checks if the given class implements a specific interface, works for both native and blueprint interfacse",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "TestClass",
          "type": "const UClass"
        },
        {
          "name": "Interface",
          "type": "TSubclassOf<UInterface>"
        }
      ]
    },
    {
      "name": "DoesImplementInterface",
      "return": "bool",
      "doc": "Checks if the given object implements a specific interface, works for both native and blueprint interfacse",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "TestObject",
          "type": "const UObject"
        },
        {
          "name": "Interface",
          "type": "TSubclassOf<UInterface>"
        }
      ]
    },
    {
      "name": "DrawDebugArrow",
      "return": "void",
      "doc": "Draw directional arrow, pointing from LineStart to LineEnd.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "LineStart",
          "type": "FVector"
        },
        {
          "name": "LineEnd",
          "type": "FVector"
        },
        {
          "name": "ArrowSize",
          "type": "float32"
        },
        {
          "name": "LineColor",
          "type": "FLinearColor"
        },
        {
          "name": "Duration",
          "default": "0.000000",
          "type": "float32"
        },
        {
          "name": "Thickness",
          "default": "0.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "DrawDebugBox",
      "return": "void",
      "doc": "Draw a debug box",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Center",
          "type": "FVector"
        },
        {
          "name": "Extent",
          "type": "FVector"
        },
        {
          "name": "LineColor",
          "type": "FLinearColor"
        },
        {
          "name": "Rotation",
          "default": "FRotator ( )",
          "type": "FRotator"
        },
        {
          "name": "Duration",
          "default": "0.000000",
          "type": "float32"
        },
        {
          "name": "Thickness",
          "default": "0.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "DrawDebugCamera",
      "return": "void",
      "doc": "Draw a debug camera shape.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "CameraActor",
          "type": "const ACameraActor"
        },
        {
          "name": "CameraColor",
          "default": "FLinearColor ( 1.000000 , 1.000000 , 1.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "Duration",
          "default": "0.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "DrawDebugCapsule",
      "return": "void",
      "doc": "Draw a debug capsule",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Center",
          "type": "FVector"
        },
        {
          "name": "HalfHeight",
          "type": "float32"
        },
        {
          "name": "Radius",
          "type": "float32"
        },
        {
          "name": "Rotation",
          "type": "FRotator"
        },
        {
          "name": "LineColor",
          "default": "FLinearColor ( 1.000000 , 1.000000 , 1.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "Duration",
          "default": "0.000000",
          "type": "float32"
        },
        {
          "name": "Thickness",
          "default": "0.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "DrawDebugCircle",
      "return": "void",
      "doc": "Draw a debug circle!",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Center",
          "type": "FVector"
        },
        {
          "name": "Radius",
          "type": "float32"
        },
        {
          "name": "NumSegments",
          "default": "12",
          "type": "int"
        },
        {
          "name": "LineColor",
          "default": "FLinearColor ( 1.000000 , 1.000000 , 1.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "Duration",
          "default": "0.000000",
          "type": "float32"
        },
        {
          "name": "Thickness",
          "default": "0.000000",
          "type": "float32"
        },
        {
          "name": "YAxis",
          "default": "FVector ( 0.000000 , 1.000000 , 0.000000 )",
          "type": "FVector"
        },
        {
          "name": "ZAxis",
          "default": "FVector ( 0.000000 , 0.000000 , 1.000000 )",
          "type": "FVector"
        },
        {
          "name": "bDrawAxis",
          "default": "false",
          "type": "bool"
        }
      ]
    },
    {
      "name": "DrawDebugConeInDegrees",
      "return": "void",
      "doc": "Draw a debug cone\nAngles are specified in degrees",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Origin",
          "type": "FVector"
        },
        {
          "name": "Direction",
          "type": "FVector"
        },
        {
          "name": "Length",
          "default": "100.000000",
          "type": "float32"
        },
        {
          "name": "AngleWidth",
          "default": "45.000000",
          "type": "float32"
        },
        {
          "name": "AngleHeight",
          "default": "45.000000",
          "type": "float32"
        },
        {
          "name": "NumSides",
          "default": "12",
          "type": "int"
        },
        {
          "name": "LineColor",
          "default": "FLinearColor ( 1.000000 , 1.000000 , 1.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "Duration",
          "default": "0.000000",
          "type": "float32"
        },
        {
          "name": "Thickness",
          "default": "0.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "DrawDebugCoordinateSystem",
      "return": "void",
      "doc": "Draw a debug coordinate system.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "AxisLoc",
          "type": "FVector"
        },
        {
          "name": "AxisRot",
          "type": "FRotator"
        },
        {
          "name": "Scale",
          "default": "1.000000",
          "type": "float32"
        },
        {
          "name": "Duration",
          "default": "0.000000",
          "type": "float32"
        },
        {
          "name": "Thickness",
          "default": "0.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "DrawDebugCylinder",
      "return": "void",
      "doc": "Draw a debug cylinder",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Start",
          "type": "FVector"
        },
        {
          "name": "End",
          "type": "FVector"
        },
        {
          "name": "Radius",
          "default": "100.000000",
          "type": "float32"
        },
        {
          "name": "Segments",
          "default": "12",
          "type": "int"
        },
        {
          "name": "LineColor",
          "default": "FLinearColor ( 1.000000 , 1.000000 , 1.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "Duration",
          "default": "0.000000",
          "type": "float32"
        },
        {
          "name": "Thickness",
          "default": "0.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "DrawDebugFloatHistoryLocation",
      "return": "void",
      "doc": "Draws a 2D Histogram of size 'DrawSize' based FDebugFloatHistory struct, using DrawLocation for the location in the world, rotation will face camera of first player.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "FloatHistory",
          "type": "FDebugFloatHistory"
        },
        {
          "name": "DrawLocation",
          "type": "FVector"
        },
        {
          "name": "DrawSize",
          "type": "FVector2D"
        },
        {
          "name": "DrawColor",
          "default": "FLinearColor ( 1.000000 , 1.000000 , 1.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "Duration",
          "default": "0.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "DrawDebugFloatHistoryTransform",
      "return": "void",
      "doc": "Draws a 2D Histogram of size 'DrawSize' based FDebugFloatHistory struct, using DrawTransform for the position in the world.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "FloatHistory",
          "type": "FDebugFloatHistory"
        },
        {
          "name": "DrawTransform",
          "type": "FTransform"
        },
        {
          "name": "DrawSize",
          "type": "FVector2D"
        },
        {
          "name": "DrawColor",
          "default": "FLinearColor ( 1.000000 , 1.000000 , 1.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "Duration",
          "default": "0.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "DrawDebugFrustum",
      "return": "void",
      "doc": "Draws a debug frustum.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "FrustumTransform",
          "type": "FTransform"
        },
        {
          "name": "FrustumColor",
          "default": "FLinearColor ( 1.000000 , 1.000000 , 1.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "Duration",
          "default": "0.000000",
          "type": "float32"
        },
        {
          "name": "Thickness",
          "default": "0.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "DrawDebugLine",
      "return": "void",
      "doc": "Draw a debug line",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "LineStart",
          "type": "FVector"
        },
        {
          "name": "LineEnd",
          "type": "FVector"
        },
        {
          "name": "LineColor",
          "type": "FLinearColor"
        },
        {
          "name": "Duration",
          "default": "0.000000",
          "type": "float32"
        },
        {
          "name": "Thickness",
          "default": "0.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "DrawDebugPlane",
      "return": "void",
      "doc": "Draws a debug plane.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "PlaneCoordinates",
          "type": "FPlane"
        },
        {
          "name": "Location",
          "type": "FVector"
        },
        {
          "name": "Size",
          "type": "float32"
        },
        {
          "name": "PlaneColor",
          "default": "FLinearColor ( 1.000000 , 1.000000 , 1.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "Duration",
          "default": "0.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "DrawDebugPoint",
      "return": "void",
      "doc": "Draw a debug point",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Position",
          "type": "FVector"
        },
        {
          "name": "Size",
          "type": "float32"
        },
        {
          "name": "PointColor",
          "type": "FLinearColor"
        },
        {
          "name": "Duration",
          "default": "0.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "DrawDebugSphere",
      "return": "void",
      "doc": "Draw a debug sphere",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Center",
          "type": "FVector"
        },
        {
          "name": "Radius",
          "default": "100.000000",
          "type": "float32"
        },
        {
          "name": "Segments",
          "default": "12",
          "type": "int"
        },
        {
          "name": "LineColor",
          "default": "FLinearColor ( 1.000000 , 1.000000 , 1.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "Duration",
          "default": "0.000000",
          "type": "float32"
        },
        {
          "name": "Thickness",
          "default": "0.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "DrawDebugString",
      "return": "void",
      "doc": "Draw a debug string at a 3d world location.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "TextLocation",
          "type": "FVector"
        },
        {
          "name": "Text",
          "type": "FString"
        },
        {
          "name": "TestBaseActor",
          "default": "nullptr",
          "type": "AActor"
        },
        {
          "name": "TextColor",
          "default": "FLinearColor ( 1.000000 , 1.000000 , 1.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "Duration",
          "default": "0.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "EndTransaction",
      "return": "int",
      "doc": "Attempt to end the current undo transaction. Only successful if the transaction's action counter is 1.\n@note Only available in the editor.\n\n@return      The number of active actions when EndTransaction was called (a value of 1 indicates that the transaction was successfully closed), or -1 on failure.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "EqualEqual_PrimaryAssetId",
      "return": "bool",
      "doc": "Returns true if the values are equal (A == B)",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "A",
          "type": "FPrimaryAssetId"
        },
        {
          "name": "B",
          "type": "FPrimaryAssetId"
        }
      ]
    },
    {
      "name": "EqualEqual_PrimaryAssetType",
      "return": "bool",
      "doc": "Returns true if the values are equal (A == B)",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "A",
          "type": "FPrimaryAssetType"
        },
        {
          "name": "B",
          "type": "FPrimaryAssetType"
        }
      ]
    },
    {
      "name": "EqualEqual_SoftClassReference",
      "return": "bool",
      "doc": "Returns true if the values are equal (A == B)",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "A",
          "type": "TSoftClassPtr<UObject>"
        },
        {
          "name": "B",
          "type": "TSoftClassPtr<UObject>"
        }
      ]
    },
    {
      "name": "EqualEqual_SoftObjectReference",
      "return": "bool",
      "doc": "Returns true if the values are equal (A == B)",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "A",
          "type": "TSoftObjectPtr<UObject>"
        },
        {
          "name": "B",
          "type": "TSoftObjectPtr<UObject>"
        }
      ]
    },
    {
      "name": "ExecuteConsoleCommand",
      "return": "void",
      "doc": "Executes a console command, optionally on a specific controller\n\n@param       Command                 Command to send to the console\n@param       SpecificPlayer  If specified, the console command will be routed through the specified player",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Command",
          "type": "FString"
        },
        {
          "name": "SpecificPlayer",
          "default": "nullptr",
          "type": "APlayerController"
        }
      ]
    },
    {
      "name": "FlushDebugStrings",
      "return": "void",
      "doc": "Removes all debug strings.\n\n@param WorldContext  World context",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "FlushPersistentDebugLines",
      "return": "void",
      "doc": "Flush all persistent debug lines and shapes.\n\n@param WorldContext  World context",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "ForceCloseAdBanner",
      "return": "void",
      "doc": "Forces closed any displayed ad. Can lead to loss of revenue\n(iOS and Android only)",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetActorListFromComponentList",
      "return": "void",
      "doc": "Returns an array of unique actors represented by the given list of components.\n@param ComponentList         List of components.\n@param ClassFilter           If set, will only return results of this class or subclasses of it.\n@param OutActorList          Start of line segment.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "ComponentList",
          "type": "TArray<UPrimitiveComponent>"
        },
        {
          "name": "ActorClassFilter",
          "type": "UClass"
        },
        {
          "name": "OutActorList",
          "type": "TArray<AActor>&"
        }
      ]
    },
    {
      "name": "GetAdIDCount",
      "return": "int",
      "doc": "Retrieves the total number of Ad IDs that can be selected between",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetBuildConfiguration",
      "return": "FString",
      "doc": "Build configuration, for displaying to end users in diagnostics.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetBuildVersion",
      "return": "FString",
      "doc": "Build version, for displaying to end users in diagnostics.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetClassDisplayName",
      "return": "FString",
      "doc": "Returns the display name of a class",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Class",
          "type": "const UClass"
        }
      ]
    },
    {
      "name": "GetClassFromPrimaryAssetId",
      "return": "TSubclassOf<UObject>",
      "doc": "Returns the Blueprint Class associated with a Primary Asset Id, this will only return a valid object if it is in memory, it will not load it",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "PrimaryAssetId",
          "type": "FPrimaryAssetId"
        }
      ]
    },
    {
      "name": "GetClassTopLevelAssetPath",
      "return": "FTopLevelAssetPath",
      "doc": "Returns the full path to the specified class as a Top Level Asset Path used by asset utilities",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Class",
          "type": "const UClass"
        }
      ]
    },
    {
      "name": "GetCommandLine",
      "return": "FString",
      "doc": "Returns the command line that the process was launched with.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetComponentBounds",
      "return": "void",
      "doc": "Get bounds",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Component",
          "type": "const USceneComponent"
        },
        {
          "name": "Origin",
          "type": "FVector&"
        },
        {
          "name": "BoxExtent",
          "type": "FVector&"
        },
        {
          "name": "SphereRadius",
          "type": "float32&"
        }
      ]
    },
    {
      "name": "GetConsoleVariableBoolValue",
      "return": "bool",
      "doc": "Evaluates, if it exists, whether the specified integer console variable has a non-zero value (true) or not (false).\n\n@param       VariableName    Name of the console variable to find.\n@return      True if found and has a non-zero value, false otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "VariableName",
          "type": "FString"
        }
      ]
    },
    {
      "name": "GetConsoleVariableFloatValue",
      "return": "float32",
      "doc": "Attempts to retrieve the value of the specified float console variable, if it exists.\n\n@param       VariableName    Name of the console variable to find.\n@return      The value if found, 0 otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "VariableName",
          "type": "FString"
        }
      ]
    },
    {
      "name": "GetConsoleVariableIntValue",
      "return": "int",
      "doc": "Attempts to retrieve the value of the specified integer console variable, if it exists.\n\n@param       VariableName    Name of the console variable to find.\n@return      The value if found, 0 otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "VariableName",
          "type": "FString"
        }
      ]
    },
    {
      "name": "GetConsoleVariableStringValue",
      "return": "FString",
      "doc": "Attempts to retrieve the value of the specified string console variable, if it exists.\n\n@param       VariableName    Name of the console variable to find.\n@return      The value if found, empty string otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "VariableName",
          "type": "FString"
        }
      ]
    },
    {
      "name": "GetConvenientWindowedResolutions",
      "return": "bool",
      "doc": "Gets the list of windowed resolutions which are convenient for the current primary display size.\n@return true if successfully queried the device for available resolutions.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Resolutions",
          "type": "TArray<FIntPoint>&"
        }
      ]
    },
    {
      "name": "GetCurrentBundleState",
      "return": "bool",
      "doc": "Returns the list of loaded bundles for a given Primary Asset. This will return false if the asset is not loaded at all.\nIf ForceCurrentState is true it will return the current state even if a load is in process",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "PrimaryAssetId",
          "type": "FPrimaryAssetId"
        },
        {
          "name": "bForceCurrentState",
          "type": "bool"
        },
        {
          "name": "OutBundles",
          "type": "TArray<FName>&"
        }
      ]
    },
    {
      "name": "GetDefaultLanguage",
      "return": "FString",
      "doc": "Get the default language (for localization) used by this platform\n@note This is typically the same as GetDefaultLocale unless the platform distinguishes between the two\n@note This should be returned in IETF language tag form:\n - A two-letter ISO 639-1 language code (eg, \"zh\")\n - An optional four-letter ISO 15924 script code (eg, \"Hans\")\n - An optional two-letter ISO 3166-1 country code (eg, \"CN\")\n@return The language as an IETF language tag (eg, \"zh-Hans-CN\")",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetDefaultLocale",
      "return": "FString",
      "doc": "Get the default locale (for internationalization) used by this platform\n@note This should be returned in IETF language tag form:\n - A two-letter ISO 639-1 language code (eg, \"zh\")\n - An optional four-letter ISO 15924 script code (eg, \"Hans\")\n - An optional two-letter ISO 3166-1 country code (eg, \"CN\")\n@return The locale as an IETF language tag (eg, \"zh-Hans-CN\")",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetDeviceId",
      "return": "FString",
      "doc": "Returns the platform specific unique device id",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetDisplayName",
      "return": "FString",
      "doc": "Returns the display name (or actor label), for displaying as a debugging aid.\nNote: In editor builds, this is the actor label.  In non-editor builds, this is the actual object name.  This function should not be used to uniquely identify actors!\nIt is not localized and should not be used for display to an end user of a game.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Object",
          "type": "const UObject"
        }
      ]
    },
    {
      "name": "GetEngineVersion",
      "return": "FString",
      "doc": "Engine build number, for displaying to end users.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetEnumTopLevelAssetPath",
      "return": "FTopLevelAssetPath",
      "doc": "Returns the full path to the specified enum as a Top Level Asset Path used by asset utilities",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Enum",
          "type": "const UEnum"
        }
      ]
    },
    {
      "name": "GetFrameCount",
      "return": "int64",
      "doc": "Returns the value of GFrameCounter, a running count of the number of frames that have occurred.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetGameBundleId",
      "return": "FString",
      "doc": "Retrieves the game's platform-specific bundle identifier or package name of the game\n\n@return The game's bundle identifier or package name.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetGameName",
      "return": "FString",
      "doc": "Get the name of the current game",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetGamepadButtonGlyph",
      "return": "UTexture2D",
      "doc": "Returns glyph assigned to a gamepad button (or a null ptr if not assigned) (iOS and tvOS only)",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "ButtonKey",
          "type": "FString"
        },
        {
          "name": "ControllerIndex",
          "type": "int"
        }
      ]
    },
    {
      "name": "GetGamepadControllerName",
      "return": "FString",
      "doc": "Returns name of controller if assigned to a gamepad (or None if not assigned) (Android and iOS only)",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "ControllerId",
          "type": "int"
        }
      ]
    },
    {
      "name": "GetGameTimeInSeconds",
      "return": "float",
      "doc": "Get the current game time, in seconds. This stops when the game is paused and is affected by slomo.\n\n@param WorldContextObject    World context",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetLocalCurrencyCode",
      "return": "FString",
      "doc": "Returns the currency code associated with the device's locale\n@return the currency code associated with the device's locale",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetLocalCurrencySymbol",
      "return": "FString",
      "doc": "Returns the currency symbol associated with the device's locale\n@return the currency symbol associated with the device's locale",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetMinYResolutionFor3DView",
      "return": "int",
      "doc": "Gets the smallest Y resolution we want to support in the 3D view, clamped within reasons\n@return value in pixels",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetMinYResolutionForUI",
      "return": "int",
      "doc": "Gets the smallest Y resolution we want to support in the UI, clamped within reasons\n@return value in pixels",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetObjectFromPrimaryAssetId",
      "return": "UObject",
      "doc": "Returns the Object associated with a Primary Asset Id, this will only return a valid object if it is in memory, it will not load it",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "PrimaryAssetId",
          "type": "FPrimaryAssetId"
        }
      ]
    },
    {
      "name": "GetObjectName",
      "return": "FString",
      "doc": "Returns the actual object name.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Object",
          "type": "const UObject"
        }
      ]
    },
    {
      "name": "GetOuterObject",
      "return": "UObject",
      "doc": "Returns the outer object of an object.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Object",
          "type": "const UObject"
        }
      ]
    },
    {
      "name": "GetPathName",
      "return": "FString",
      "doc": "Returns the full path to the specified object as a string",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Object",
          "type": "const UObject"
        }
      ]
    },
    {
      "name": "GetPlatformTime_Seconds",
      "return": "float",
      "doc": "Returns the current platform time in seconds. Not coupled to any gameplay or other containerization logic - this\nfunction is useful for timing execution time or timestamping data. Marked as callable rather than pure because\nimplicit evaluation may be confusing, both for blueprint authors and blueprint readers. For implicit execution\nsimply wrap it in a blueprint pure function.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetPlatformUserDir",
      "return": "FString",
      "doc": "Get the current user dir from the OS",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetPlatformUserName",
      "return": "FString",
      "doc": "Get the current user name from the OS",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetPreferredLanguages",
      "return": "TArray<FString>",
      "doc": "Returns an array of the user's preferred languages in order of preference\n@return An array of language IDs ordered from most preferred to least",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetPrimaryAssetIdFromClass",
      "return": "FPrimaryAssetId",
      "doc": "Returns the Primary Asset Id for a Class, this can return an invalid one if not registered",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Class",
          "type": "TSubclassOf<UObject>"
        }
      ]
    },
    {
      "name": "GetPrimaryAssetIdFromObject",
      "return": "FPrimaryAssetId",
      "doc": "Returns the Primary Asset Id for an Object, this can return an invalid one if not registered",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Object",
          "type": "UObject"
        }
      ]
    },
    {
      "name": "GetPrimaryAssetIdFromSoftClassReference",
      "return": "FPrimaryAssetId",
      "doc": "Returns the Primary Asset Id for a Soft Class Reference, this can return an invalid one if not registered",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "SoftClassReference",
          "type": "TSoftClassPtr<UObject>"
        }
      ]
    },
    {
      "name": "GetPrimaryAssetIdFromSoftObjectReference",
      "return": "FPrimaryAssetId",
      "doc": "Returns the Primary Asset Id for a Soft Object Reference, this can return an invalid one if not registered",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "SoftObjectReference",
          "type": "TSoftObjectPtr<UObject>"
        }
      ]
    },
    {
      "name": "GetPrimaryAssetIdList",
      "return": "void",
      "doc": "Returns list of PrimaryAssetIds for a PrimaryAssetType",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "PrimaryAssetType",
          "type": "FPrimaryAssetType"
        },
        {
          "name": "OutPrimaryAssetIdList",
          "type": "TArray<FPrimaryAssetId>&"
        }
      ]
    },
    {
      "name": "GetPrimaryAssetsWithBundleState",
      "return": "void",
      "doc": "Returns the list of assets that are in a given bundle state. Required Bundles must be specified\nIf ExcludedBundles is not empty, it will not return any assets in those bundle states\nIf ValidTypes is not empty, it will only return assets of those types\nIf ForceCurrentState is true it will use the current state even if a load is in process",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "RequiredBundles",
          "type": "TArray<FName>"
        },
        {
          "name": "ExcludedBundles",
          "type": "TArray<FName>"
        },
        {
          "name": "ValidTypes",
          "type": "TArray<FPrimaryAssetType>"
        },
        {
          "name": "bForceCurrentState",
          "type": "bool"
        },
        {
          "name": "OutPrimaryAssetIdList",
          "type": "TArray<FPrimaryAssetId>&"
        }
      ]
    },
    {
      "name": "GetProjectContentDirectory",
      "return": "FString",
      "doc": "Get the content directory of the current project",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetProjectDirectory",
      "return": "FString",
      "doc": "Get the directory of the current project",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetProjectSavedDirectory",
      "return": "FString",
      "doc": "Get the saved directory of the current project",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetRenderingDetailMode",
      "return": "int",
      "doc": "Get the clamped state of r.DetailMode, see console variable help (allows for scalability, cannot be used in construction scripts)\n0: low, show objects with DetailMode low\n1: medium, show objects with DetailMode medium or below\n2: high, show objects with DetailMode high or below\n3: epic, show all objects",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetRenderingMaterialQualityLevel",
      "return": "int",
      "doc": "Get the clamped state of r.MaterialQualityLevel, see console variable help (allows for scalability, cannot be used in construction scripts)\n0: low\n1: high\n2: medium",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "GetSoftClassPath",
      "return": "FSoftClassPath",
      "doc": "Returns the full path to the specified class as a Soft Class Path (that can be used as a Soft Object Path)",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Class",
          "type": "const UClass"
        }
      ]
    },
    {
      "name": "GetSoftClassReferenceFromPrimaryAssetId",
      "return": "TSoftClassPtr<UObject>",
      "doc": "Returns the Blueprint Class Id associated with a Primary Asset Id, this works even if the asset is not loaded",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "PrimaryAssetId",
          "type": "FPrimaryAssetId"
        }
      ]
    },
    {
      "name": "GetSoftClassTopLevelAssetPath",
      "return": "FTopLevelAssetPath",
      "doc": "Converts a Soft Class Reference to a Top Level Asset Path used by asset utilities",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "SoftClassReference",
          "type": "TSoftClassPtr<UObject>"
        }
      ]
    },
    {
      "name": "GetSoftObjectPath",
      "return": "FSoftObjectPath",
      "doc": "Returns the full path to the specified object as a Soft Object Path",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Object",
          "type": "const UObject"
        }
      ]
    },
    {
      "name": "GetSoftObjectReferenceFromPrimaryAssetId",
      "return": "TSoftObjectPtr<UObject>",
      "doc": "Returns the Object Id associated with a Primary Asset Id, this works even if the asset is not loaded",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "PrimaryAssetId",
          "type": "FPrimaryAssetId"
        }
      ]
    },
    {
      "name": "GetStructTopLevelAssetPath",
      "return": "FTopLevelAssetPath",
      "doc": "Returns the full path to the specified struct as a Top Level Asset Path used by asset utilities",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Struct",
          "type": "const UScriptStruct"
        }
      ]
    },
    {
      "name": "GetSupportedFullscreenResolutions",
      "return": "bool",
      "doc": "Gets the list of support fullscreen resolutions.\n@return true if successfully queried the device for available resolutions.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Resolutions",
          "type": "TArray<FIntPoint>&"
        }
      ]
    },
    {
      "name": "GetSystemPath",
      "return": "FString",
      "doc": "Returns the full file system path to a UObject\nIf given a non-asset UObject, it will return an empty string",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Object",
          "type": "const UObject"
        }
      ]
    },
    {
      "name": "GetVolumeButtonsHandledBySystem",
      "return": "bool",
      "doc": "Returns true if system default handling of volume up and volume down buttons enabled (Android only)",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "HasMultipleLocalPlayers",
      "return": "bool",
      "doc": "Returns whether there are currently multiple local players in the given world",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "HideAdBanner",
      "return": "void",
      "doc": "Hides the ad banner (iAd on iOS, or AdMob on Android). Will force close the ad if it's open\n(iOS and Android only)",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "IsControllerAssignedToGamepad",
      "return": "bool",
      "doc": "Returns true if controller id assigned to a gamepad (Android and iOS only)",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "ControllerId",
          "type": "int"
        }
      ]
    },
    {
      "name": "IsDedicatedServer",
      "return": "bool",
      "doc": "Returns whether this is running on a dedicated server",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "IsInterstitialAdAvailable",
      "return": "bool",
      "doc": "Returns true if the requested interstitial ad is loaded and ready\n(Android only)",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "IsInterstitialAdRequested",
      "return": "bool",
      "doc": "Returns true if the requested interstitial ad has been successfully requested (false if load request fails)\n(Android only)",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "IsLoggedIn",
      "return": "bool",
      "doc": "Returns whether the player is logged in to the currently active online subsystem.\n\n@param Player Specific player's login status to get. May not be supported on all platforms. If null, defaults to the player with ControllerId 0.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "SpecificPlayer",
          "type": "const APlayerController"
        }
      ]
    },
    {
      "name": "IsPackagedForDistribution",
      "return": "bool",
      "doc": "Returns whether this is a build that is packaged for distribution",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "IsScreensaverEnabled",
      "return": "bool",
      "doc": "Returns true if screen saver is enabled.",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "IsServer",
      "return": "bool",
      "doc": "Returns whether the world this object is in is the host or not",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "IsStandalone",
      "return": "bool",
      "doc": "Returns whether this game instance is stand alone (no networking).",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "IsUnattended",
      "return": "bool",
      "doc": "Returns true if running unattended (-unattended is on the command line)\n\n@return      Unattended state",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "IsValid",
      "return": "bool",
      "doc": "Return true if the object is usable : non-null and not pending kill",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Object",
          "type": "const UObject"
        }
      ]
    },
    {
      "name": "IsValidClass",
      "return": "bool",
      "doc": "Return true if the class is usable : non-null and not pending kill",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Class",
          "type": "UClass"
        }
      ]
    },
    {
      "name": "IsValidPrimaryAssetId",
      "return": "bool",
      "doc": "Returns true if the Primary Asset Id is valid",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "PrimaryAssetId",
          "type": "FPrimaryAssetId"
        }
      ]
    },
    {
      "name": "IsValidPrimaryAssetType",
      "return": "bool",
      "doc": "Returns list of Primary Asset Ids for a PrimaryAssetType",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "PrimaryAssetType",
          "type": "FPrimaryAssetType"
        }
      ]
    },
    {
      "name": "IsValidSoftClassReference",
      "return": "bool",
      "doc": "Returns true if the Soft Class Reference is not null",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "SoftClassReference",
          "type": "TSoftClassPtr<UObject>"
        }
      ]
    },
    {
      "name": "IsValidSoftObjectReference",
      "return": "bool",
      "doc": "Returns true if the Soft Object Reference is not null",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "SoftObjectReference",
          "type": "TSoftObjectPtr<UObject>"
        }
      ]
    },
    {
      "name": "ClearAndInvalidateTimerHandle",
      "return": "void",
      "doc": "Clears a set timer.\n@param Handle                The handle of the timer to clear.",
      "ufunction": true,
      "unrealname": "K2_ClearAndInvalidateTimerHandle",
      "meta": null,
      "args": [
        {
          "name": "Handle",
          "type": "FTimerHandle&"
        }
      ]
    },
    {
      "name": "ClearTimer",
      "return": "void",
      "doc": "Clears a set timer.\n@param Object                Object that implements the delegate function. Defaults to self (this blueprint)\n@param FunctionName  Delegate function name. Can be a K2 function or a Custom Event.",
      "ufunction": true,
      "unrealname": "K2_ClearTimer",
      "meta": null,
      "args": [
        {
          "name": "Object",
          "type": "UObject"
        },
        {
          "name": "FunctionName",
          "type": "FString"
        }
      ]
    },
    {
      "name": "GetTimerElapsedTime",
      "return": "float32",
      "doc": "Returns elapsed time for the given delegate (time since current countdown iteration began).\n@param Object                Object that implements the delegate function. Defaults to self (this blueprint)\n@param FunctionName  Delegate function name. Can be a K2 function or a Custom Event.\n@return                              How long has elapsed since the current iteration of the timer began.",
      "ufunction": true,
      "unrealname": "K2_GetTimerElapsedTime",
      "meta": null,
      "args": [
        {
          "name": "Object",
          "type": "UObject"
        },
        {
          "name": "FunctionName",
          "type": "FString"
        }
      ]
    },
    {
      "name": "GetTimerElapsedTimeHandle",
      "return": "float32",
      "doc": "Returns elapsed time for the given handle (time since current countdown iteration began).\n@param Handle                The handle of the timer to get the elapsed time of.\n@return                              How long has elapsed since the current iteration of the timer began.",
      "ufunction": true,
      "unrealname": "K2_GetTimerElapsedTimeHandle",
      "meta": null,
      "args": [
        {
          "name": "Handle",
          "type": "FTimerHandle"
        }
      ]
    },
    {
      "name": "GetTimerRemainingTime",
      "return": "float32",
      "doc": "Returns time until the timer will next execute its delegate.\n@param Object                Object that implements the delegate function. Defaults to self (this blueprint)\n@param FunctionName  Delegate function name. Can be a K2 function or a Custom Event.\n@return                              How long is remaining in the current iteration of the timer.",
      "ufunction": true,
      "unrealname": "K2_GetTimerRemainingTime",
      "meta": null,
      "args": [
        {
          "name": "Object",
          "type": "UObject"
        },
        {
          "name": "FunctionName",
          "type": "FString"
        }
      ]
    },
    {
      "name": "GetTimerRemainingTimeHandle",
      "return": "float32",
      "doc": "Returns time until the timer will next execute its handle.\n@param Handle                The handle of the timer to time remaining of.\n@return                              How long is remaining in the current iteration of the timer.",
      "ufunction": true,
      "unrealname": "K2_GetTimerRemainingTimeHandle",
      "meta": null,
      "args": [
        {
          "name": "Handle",
          "type": "FTimerHandle"
        }
      ]
    },
    {
      "name": "InvalidateTimerHandle",
      "return": "FTimerHandle",
      "doc": "Invalidate the supplied TimerHandle and return it.\n@param Handle                The handle of the timer to invalidate.\n@return                              Return the invalidated timer handle for convenience.",
      "ufunction": true,
      "unrealname": "K2_InvalidateTimerHandle",
      "meta": null,
      "args": [
        {
          "name": "Handle",
          "type": "FTimerHandle&"
        }
      ]
    },
    {
      "name": "IsTimerActive",
      "return": "bool",
      "doc": "Returns true if a timer exists and is active for the given delegate, false otherwise.\n@param Object                Object that implements the delegate function. Defaults to self (this blueprint)\n@param FunctionName  Delegate function name. Can be a K2 function or a Custom Event.\n@return                              True if the timer exists and is active.",
      "ufunction": true,
      "unrealname": "K2_IsTimerActive",
      "meta": null,
      "args": [
        {
          "name": "Object",
          "type": "UObject"
        },
        {
          "name": "FunctionName",
          "type": "FString"
        }
      ]
    },
    {
      "name": "IsTimerActiveHandle",
      "return": "bool",
      "doc": "Returns true if a timer exists and is active for the given handle, false otherwise.\n@param Handle                The handle of the timer to check whether it is active.\n@return                              True if the timer exists and is active.",
      "ufunction": true,
      "unrealname": "K2_IsTimerActiveHandle",
      "meta": null,
      "args": [
        {
          "name": "Handle",
          "type": "FTimerHandle"
        }
      ]
    },
    {
      "name": "IsTimerPaused",
      "return": "bool",
      "doc": "Returns true if a timer exists and is paused for the given delegate, false otherwise.\n@param Object         Object that implements the delegate function. Defaults to self (this blueprint)\n@param FunctionName   Delegate function name. Can be a K2 function or a Custom Event.\n@return                               True if the timer exists and is paused.",
      "ufunction": true,
      "unrealname": "K2_IsTimerPaused",
      "meta": null,
      "args": [
        {
          "name": "Object",
          "type": "UObject"
        },
        {
          "name": "FunctionName",
          "type": "FString"
        }
      ]
    },
    {
      "name": "IsTimerPausedHandle",
      "return": "bool",
      "doc": "Returns true if a timer exists and is paused for the given handle, false otherwise.\n@param Handle                The handle of the timer to check whether it is paused.\n@return                              True if the timer exists and is paused.",
      "ufunction": true,
      "unrealname": "K2_IsTimerPausedHandle",
      "meta": null,
      "args": [
        {
          "name": "Handle",
          "type": "FTimerHandle"
        }
      ]
    },
    {
      "name": "IsValidTimerHandle",
      "return": "bool",
      "doc": "Returns whether the timer handle is valid. This does not indicate that there is an active timer that this handle references, but rather that it once referenced a valid timer.\n@param Handle                The handle of the timer to check validity of.\n@return                              Whether the timer handle is valid.",
      "ufunction": true,
      "unrealname": "K2_IsValidTimerHandle",
      "meta": null,
      "args": [
        {
          "name": "Handle",
          "type": "FTimerHandle"
        }
      ]
    },
    {
      "name": "PauseTimer",
      "return": "void",
      "doc": "Pauses a set timer at its current elapsed time.\n@param Object                Object that implements the delegate function. Defaults to self (this blueprint)\n@param FunctionName  Delegate function name. Can be a K2 function or a Custom Event.",
      "ufunction": true,
      "unrealname": "K2_PauseTimer",
      "meta": null,
      "args": [
        {
          "name": "Object",
          "type": "UObject"
        },
        {
          "name": "FunctionName",
          "type": "FString"
        }
      ]
    },
    {
      "name": "PauseTimerHandle",
      "return": "void",
      "doc": "Pauses a set timer at its current elapsed time.\n@param Handle                The handle of the timer to pause.",
      "ufunction": true,
      "unrealname": "K2_PauseTimerHandle",
      "meta": null,
      "args": [
        {
          "name": "Handle",
          "type": "FTimerHandle"
        }
      ]
    },
    {
      "name": "SetTimer",
      "return": "FTimerHandle",
      "doc": "Set a timer to execute delegate. Setting an existing timer will reset that timer with updated parameters.\n@param Object                                        Object that implements the delegate function. Defaults to self (this blueprint)\n@param FunctionName                          Delegate function name. Can be a K2 function or a Custom Event.\n@param Time                                          How long to wait before executing the delegate, in seconds. Setting a timer to <= 0 seconds will clear it if it is set.\n@param bLooping                                      True to keep executing the delegate every Time seconds, false to execute delegate only once.\n@param bMaxOncePerFrame                      For looping timers, whether to execute only once when the timer would otherwise expires multiple times in the current frame.\n@param InitialStartDelay                     Initial delay passed to the timer manager to allow some variance in when the timer starts, in seconds.\n@param InitialStartDelayVariance     Use this to add some variance to when the timer starts in lieu of doing a random range on the InitialStartDelay input, in seconds.\n@return                                                      The timer handle to pass to other timer functions to manipulate this timer.",
      "ufunction": true,
      "unrealname": "K2_SetTimer",
      "meta": null,
      "args": [
        {
          "name": "Object",
          "type": "UObject"
        },
        {
          "name": "FunctionName",
          "type": "FName"
        },
        {
          "name": "Time",
          "type": "float32"
        },
        {
          "name": "bLooping",
          "type": "bool"
        },
        {
          "name": "bMaxOncePerFrame",
          "default": "false",
          "type": "bool"
        },
        {
          "name": "InitialStartDelay",
          "default": "0.000000",
          "type": "float32"
        },
        {
          "name": "InitialStartDelayVariance",
          "default": "0.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "SetTimerDelegate",
      "return": "FTimerHandle",
      "doc": "Set a timer to execute delegate. Setting an existing timer will reset that timer with updated parameters.\n@param Event                                         Event. Can be a K2 function or a Custom Event.\n@param Time                                          How long to wait before executing the delegate, in seconds. Setting a timer to <= 0 seconds will clear it if it is set.\n@param bLooping                                      True to keep executing the delegate every Time seconds, false to execute delegate only once.\n@param bMaxOncePerFrame                      For looping timers, whether to execute only once when the timer would otherwise expires multiple times in the current frame.\n@param InitialStartDelay                     Initial delay passed to the timer manager, in seconds.\n@param InitialStartDelayVariance     Use this to add some variance to when the timer starts in lieu of doing a random range on the InitialStartDelay input, in seconds.\n@return                                                      The timer handle to pass to other timer functions to manipulate this timer.",
      "ufunction": true,
      "unrealname": "K2_SetTimerDelegate",
      "meta": null,
      "args": [
        {
          "name": "Delegate",
          "type": "FTimerDynamicDelegate"
        },
        {
          "name": "Time",
          "type": "float32"
        },
        {
          "name": "bLooping",
          "type": "bool"
        },
        {
          "name": "bMaxOncePerFrame",
          "default": "false",
          "type": "bool"
        },
        {
          "name": "InitialStartDelay",
          "default": "0.000000",
          "type": "float32"
        },
        {
          "name": "InitialStartDelayVariance",
          "default": "0.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "SetTimerForNextTick",
      "return": "FTimerHandle",
      "doc": "Set a timer to execute a delegate on the next tick.\n@param Object                                        Object that implements the delegate function. Defaults to self (this blueprint)\n@param FunctionName                          Delegate function name. Can be a K2 function or a Custom Event.\n@return                                                      The timer handle to pass to other timer functions to manipulate this timer.",
      "ufunction": true,
      "unrealname": "K2_SetTimerForNextTick",
      "meta": null,
      "args": [
        {
          "name": "Object",
          "type": "UObject"
        },
        {
          "name": "FunctionName",
          "type": "FString"
        }
      ]
    },
    {
      "name": "SetTimerForNextTickDelegate",
      "return": "FTimerHandle",
      "doc": "Set a timer to execute a delegate next tick.\n@param Event                                         Event. Can be a K2 function or a Custom Event.\n@return                                                      The timer handle to pass to other timer functions to manipulate this timer.",
      "ufunction": true,
      "unrealname": "K2_SetTimerForNextTickDelegate",
      "meta": null,
      "args": [
        {
          "name": "Delegate",
          "default": "FTimerDynamicDelegate ( )",
          "type": "FTimerDynamicDelegate"
        }
      ]
    },
    {
      "name": "TimerExists",
      "return": "bool",
      "doc": "Returns true is a timer for the given delegate exists, false otherwise.\n@param Object         Object that implements the delegate function. Defaults to self (this blueprint)\n@param FunctionName   Delegate function name. Can be a K2 function or a Custom Event.\n@return                               True if the timer exists.",
      "ufunction": true,
      "unrealname": "K2_TimerExists",
      "meta": null,
      "args": [
        {
          "name": "Object",
          "type": "UObject"
        },
        {
          "name": "FunctionName",
          "type": "FString"
        }
      ]
    },
    {
      "name": "TimerExistsHandle",
      "return": "bool",
      "doc": "Returns true is a timer for the given handle exists, false otherwise.\n@param Handle                The handle to check whether it exists.\n@return                              True if the timer exists.",
      "ufunction": true,
      "unrealname": "K2_TimerExistsHandle",
      "meta": null,
      "args": [
        {
          "name": "Handle",
          "type": "FTimerHandle"
        }
      ]
    },
    {
      "name": "UnPauseTimer",
      "return": "void",
      "doc": "Resumes a paused timer from its current elapsed time.\n@param Object                Object that implements the delegate function. Defaults to self (this blueprint)\n@param FunctionName  Delegate function name. Can be a K2 function or a Custom Event.",
      "ufunction": true,
      "unrealname": "K2_UnPauseTimer",
      "meta": null,
      "args": [
        {
          "name": "Object",
          "type": "UObject"
        },
        {
          "name": "FunctionName",
          "type": "FString"
        }
      ]
    },
    {
      "name": "UnPauseTimerHandle",
      "return": "void",
      "doc": "Resumes a paused timer from its current elapsed time.\n@param Handle                The handle of the timer to unpause.",
      "ufunction": true,
      "unrealname": "K2_UnPauseTimerHandle",
      "meta": null,
      "args": [
        {
          "name": "Handle",
          "type": "FTimerHandle"
        }
      ]
    },
    {
      "name": "LaunchURL",
      "return": "void",
      "doc": "Opens the specified URL in the platform's web browser of choice",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "URL",
          "type": "FString"
        }
      ]
    },
    {
      "name": "LineTraceMulti",
      "return": "bool",
      "doc": "Does a collision trace along the given line and returns all hits encountered up to and including the first blocking hit.\nThis trace finds the objects that RESPOND to the given TraceChannel\n\n@param WorldContext  World context\n@param Start                 Start of line segment.\n@param End                   End of line segment.\n@param TraceChannel  The channel to trace\n@param bTraceComplex True to test against complex collision, false to test against simplified collision.\n@param OutHit                Properties of the trace hit.\n@return                              True if there was a blocking hit, false otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Start",
          "type": "FVector"
        },
        {
          "name": "End",
          "type": "FVector"
        },
        {
          "name": "TraceChannel",
          "type": "ETraceTypeQuery"
        },
        {
          "name": "bTraceComplex",
          "type": "bool"
        },
        {
          "name": "ActorsToIgnore",
          "type": "TArray<AActor>"
        },
        {
          "name": "DrawDebugType",
          "type": "EDrawDebugTrace"
        },
        {
          "name": "OutHits",
          "type": "TArray<FHitResult>&"
        },
        {
          "name": "bIgnoreSelf",
          "type": "bool"
        },
        {
          "name": "TraceColor",
          "default": "FLinearColor ( 1.000000 , 0.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "TraceHitColor",
          "default": "FLinearColor ( 0.000000 , 1.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "DrawTime",
          "default": "5.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "LineTraceMultiByProfile",
      "return": "bool",
      "doc": "Trace a ray against the world using a specific profile and return overlapping hits and then first blocking hit\nResults are sorted, so a blocking hit (if found) will be the last element of the array\nOnly the single closest blocking result will be generated, no tests will be done after that\n\n@param WorldContext   World context\n@param Start                  Start of line segment.\n@param End                    End of line segment.\n@param ProfileName    The 'profile' used to determine which components to hit\n@param bTraceComplex  True to test against complex collision, false to test against simplified collision.\n@param OutHit         Properties of the trace hit.\n@return                               True if there was a blocking hit, false otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Start",
          "type": "FVector"
        },
        {
          "name": "End",
          "type": "FVector"
        },
        {
          "name": "ProfileName",
          "type": "FName"
        },
        {
          "name": "bTraceComplex",
          "type": "bool"
        },
        {
          "name": "ActorsToIgnore",
          "type": "TArray<AActor>"
        },
        {
          "name": "DrawDebugType",
          "type": "EDrawDebugTrace"
        },
        {
          "name": "OutHits",
          "type": "TArray<FHitResult>&"
        },
        {
          "name": "bIgnoreSelf",
          "type": "bool"
        },
        {
          "name": "TraceColor",
          "default": "FLinearColor ( 1.000000 , 0.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "TraceHitColor",
          "default": "FLinearColor ( 0.000000 , 1.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "DrawTime",
          "default": "5.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "LineTraceMultiForObjects",
      "return": "bool",
      "doc": "Does a collision trace along the given line and returns all hits encountered.\nThis only finds objects that are of a type specified by ObjectTypes.\n\n@param WorldContext  World context\n@param Start                 Start of line segment.\n@param End                   End of line segment.\n@param ObjectTypes   Array of Object Types to trace\n@param bTraceComplex True to test against complex collision, false to test against simplified collision.\n@param OutHit                Properties of the trace hit.\n@return                              True if there was a hit, false otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Start",
          "type": "FVector"
        },
        {
          "name": "End",
          "type": "FVector"
        },
        {
          "name": "ObjectTypes",
          "type": "TArray<EObjectTypeQuery>"
        },
        {
          "name": "bTraceComplex",
          "type": "bool"
        },
        {
          "name": "ActorsToIgnore",
          "type": "TArray<AActor>"
        },
        {
          "name": "DrawDebugType",
          "type": "EDrawDebugTrace"
        },
        {
          "name": "OutHits",
          "type": "TArray<FHitResult>&"
        },
        {
          "name": "bIgnoreSelf",
          "type": "bool"
        },
        {
          "name": "TraceColor",
          "default": "FLinearColor ( 1.000000 , 0.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "TraceHitColor",
          "default": "FLinearColor ( 0.000000 , 1.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "DrawTime",
          "default": "5.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "LineTraceSingle",
      "return": "bool",
      "doc": "Does a collision trace along the given line and returns the first blocking hit encountered.\nThis trace finds the objects that RESPONDS to the given TraceChannel\n\n@param WorldContext  World context\n@param Start                 Start of line segment.\n@param End                   End of line segment.\n@param TraceChannel\n@param bTraceComplex True to test against complex collision, false to test against simplified collision.\n@param OutHit                Properties of the trace hit.\n@return                              True if there was a hit, false otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Start",
          "type": "FVector"
        },
        {
          "name": "End",
          "type": "FVector"
        },
        {
          "name": "TraceChannel",
          "type": "ETraceTypeQuery"
        },
        {
          "name": "bTraceComplex",
          "type": "bool"
        },
        {
          "name": "ActorsToIgnore",
          "type": "TArray<AActor>"
        },
        {
          "name": "DrawDebugType",
          "type": "EDrawDebugTrace"
        },
        {
          "name": "OutHit",
          "type": "FHitResult&"
        },
        {
          "name": "bIgnoreSelf",
          "type": "bool"
        },
        {
          "name": "TraceColor",
          "default": "FLinearColor ( 1.000000 , 0.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "TraceHitColor",
          "default": "FLinearColor ( 0.000000 , 1.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "DrawTime",
          "default": "5.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "LineTraceSingleByProfile",
      "return": "bool",
      "doc": "Trace a ray against the world using a specific profile and return the first blocking hit\n\n@param WorldContext   World context\n@param Start                  Start of line segment.\n@param End                    End of line segment.\n@param ProfileName    The 'profile' used to determine which components to hit\n@param bTraceComplex  True to test against complex collision, false to test against simplified collision.\n@param OutHit                 Properties of the trace hit.\n@return                               True if there was a hit, false otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Start",
          "type": "FVector"
        },
        {
          "name": "End",
          "type": "FVector"
        },
        {
          "name": "ProfileName",
          "type": "FName"
        },
        {
          "name": "bTraceComplex",
          "type": "bool"
        },
        {
          "name": "ActorsToIgnore",
          "type": "TArray<AActor>"
        },
        {
          "name": "DrawDebugType",
          "type": "EDrawDebugTrace"
        },
        {
          "name": "OutHit",
          "type": "FHitResult&"
        },
        {
          "name": "bIgnoreSelf",
          "type": "bool"
        },
        {
          "name": "TraceColor",
          "default": "FLinearColor ( 1.000000 , 0.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "TraceHitColor",
          "default": "FLinearColor ( 0.000000 , 1.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "DrawTime",
          "default": "5.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "LineTraceSingleForObjects",
      "return": "bool",
      "doc": "Does a collision trace along the given line and returns the first hit encountered.\nThis only finds objects that are of a type specified by ObjectTypes.\n\n@param WorldContext  World context\n@param Start                 Start of line segment.\n@param End                   End of line segment.\n@param ObjectTypes   Array of Object Types to trace\n@param bTraceComplex True to test against complex collision, false to test against simplified collision.\n@param OutHit                Properties of the trace hit.\n@return                              True if there was a hit, false otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Start",
          "type": "FVector"
        },
        {
          "name": "End",
          "type": "FVector"
        },
        {
          "name": "ObjectTypes",
          "type": "TArray<EObjectTypeQuery>"
        },
        {
          "name": "bTraceComplex",
          "type": "bool"
        },
        {
          "name": "ActorsToIgnore",
          "type": "TArray<AActor>"
        },
        {
          "name": "DrawDebugType",
          "type": "EDrawDebugTrace"
        },
        {
          "name": "OutHit",
          "type": "FHitResult&"
        },
        {
          "name": "bIgnoreSelf",
          "type": "bool"
        },
        {
          "name": "TraceColor",
          "default": "FLinearColor ( 1.000000 , 0.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "TraceHitColor",
          "default": "FLinearColor ( 0.000000 , 1.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "DrawTime",
          "default": "5.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "LoadAsset_Blocking",
      "return": "UObject",
      "doc": "Resolves or loads a Soft Object Reference immediately, this will cause hitches and Async Load Asset should be used if possible",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Asset",
          "type": "TSoftObjectPtr<UObject>"
        }
      ],
      "outputTypeIndex": 0
    },
    {
      "name": "LoadClassAsset_Blocking",
      "return": "UClass",
      "doc": "Resolves or loads a Soft Class Reference immediately, this will cause hitches and Async Load Class Asset should be used if possible",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "AssetClass",
          "type": "TSoftClassPtr<UObject>"
        }
      ],
      "outputTypeIndex": 0
    },
    {
      "name": "LoadInterstitialAd",
      "return": "void",
      "doc": "Will load a fullscreen interstitial AdMob ad. Call this before using ShowInterstitialAd\n(Android only)\n\n@param AdIdIndex The index of the ID to select for the ad to show",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "AdIdIndex",
          "type": "int"
        }
      ]
    },
    {
      "name": "LogString",
      "return": "void",
      "doc": "Prints a string to the log\nIf Print To Log is true, it will be visible in the Output Log window.  Otherwise it will be logged only as 'Verbose', so it generally won't show up.\n\n@param       InString                The string to log out\n@param       bPrintToLog             Whether or not to print the output to the log",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "InString",
          "default": "\"Hello\"",
          "type": "FString"
        },
        {
          "name": "bPrintToLog",
          "default": "true",
          "type": "bool"
        }
      ]
    },
    {
      "name": "MakeARFilter",
      "return": "FARFilter",
      "doc": "Builds an ARFilter struct. You should be using ClassPaths and RecursiveClassPathsExclusionSet, ClassNames and RecursiveClassesExclusionSet are deprecated.\n\n@param ClassNames [DEPRECATED] - Class names are now represented by path names. If non-empty, this input will result in a runtime warning. Please use the ClassPaths input instead.\n@param RecursiveClassesExclusionSet [DEPRECATED] - Class names are now represented by path names. If non-empty, this input will result in a runtime warning. Please use the RecursiveClassPathsExclusionSet input instead.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "PackageNames",
          "type": "TArray<FName>"
        },
        {
          "name": "PackagePaths",
          "type": "TArray<FName>"
        },
        {
          "name": "SoftObjectPaths",
          "type": "TArray<FSoftObjectPath>"
        },
        {
          "name": "ClassPaths",
          "type": "TArray<FTopLevelAssetPath>"
        },
        {
          "name": "RecursiveClassPathsExclusionSet",
          "type": "TSet<FTopLevelAssetPath>"
        },
        {
          "name": "ClassNames",
          "type": "TArray<FName>"
        },
        {
          "name": "RecursiveClassesExclusionSet",
          "type": "TSet<FName>"
        },
        {
          "name": "bRecursivePaths",
          "default": "false",
          "type": "bool"
        },
        {
          "name": "bRecursiveClasses",
          "default": "false",
          "type": "bool"
        },
        {
          "name": "bIncludeOnlyOnDiskAssets",
          "default": "false",
          "type": "bool"
        }
      ]
    },
    {
      "name": "MakeLiteralBool",
      "return": "bool",
      "doc": "Creates a literal bool\n@param       Value   value to set the bool to\n@return      The literal bool",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Value",
          "type": "bool"
        }
      ]
    },
    {
      "name": "MakeLiteralByte",
      "return": "uint8",
      "doc": "Creates a literal byte\n@param       Value   value to set the byte to\n@return      The literal byte",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Value",
          "type": "uint8"
        }
      ]
    },
    {
      "name": "MakeLiteralDouble",
      "return": "float",
      "doc": "Creates a literal float (double-precision)\n@param       Value   value to set the float (double-precision) to\n@return      The literal float (double-precision)",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Value",
          "type": "float"
        }
      ]
    },
    {
      "name": "MakeLiteralInt",
      "return": "int",
      "doc": "Creates a literal integer\n@param       Value   value to set the integer to\n@return      The literal integer",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Value",
          "type": "int"
        }
      ]
    },
    {
      "name": "MakeLiteralInt64",
      "return": "int64",
      "doc": "Creates a literal 64-bit integer\n@param       Value   value to set the 64-bit integer to\n@return      The literal 64-bit integer",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Value",
          "type": "int64"
        }
      ]
    },
    {
      "name": "MakeLiteralName",
      "return": "FName",
      "doc": "Creates a literal name\n@param       Value   value to set the name to\n@return      The literal name",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Value",
          "type": "FName"
        }
      ]
    },
    {
      "name": "MakeLiteralString",
      "return": "FString",
      "doc": "Creates a literal string\n@param       Value   value to set the string to\n@return      The literal string",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Value",
          "type": "FString"
        }
      ]
    },
    {
      "name": "MakeLiteralText",
      "return": "FText",
      "doc": "Creates a literal FText\n@param       Value   value to set the FText to\n@return      The literal FText",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Value",
          "type": "FText"
        }
      ]
    },
    {
      "name": "MakeSoftClassPath",
      "return": "FSoftClassPath",
      "doc": "Builds a Soft Class Path struct from a string that contains a full /folder/packagename.class path.\nFor blueprint classes, this needs to point to the actual class (often with _C) and not the blueprint editor asset",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "PathString",
          "type": "FString"
        }
      ]
    },
    {
      "name": "MakeSoftObjectPath",
      "return": "FSoftObjectPath",
      "doc": "Builds a Soft Object Path struct from a string that contains a full /folder/packagename.object path",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "PathString",
          "type": "FString"
        }
      ]
    },
    {
      "name": "MakeTopLevelAssetPath",
      "return": "FTopLevelAssetPath",
      "doc": "Builds a TopLevelAssetPath struct from single Path string or from PackageName and AssetName string.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "PackageName",
          "type": "FString"
        },
        {
          "name": "AssetName",
          "type": "FString"
        }
      ]
    },
    {
      "name": "MoveComponentTo",
      "return": "void",
      "doc": "* Interpolate a component to the specified relative location and rotation over the course of OverTime seconds.\n* @param Component                                             Component to interpolate\n* @param TargetRelativeLocation                Relative target location\n* @param TargetRelativeRotation                Relative target rotation\n* @param bEaseOut                                              if true we will ease out (ie end slowly) during interpolation\n* @param bEaseIn                                               if true we will ease in (ie start slowly) during interpolation\n* @param OverTime                                              duration of interpolation\n* @param bForceShortestRotationPath    if true we will always use the shortest path for rotation\n* @param MoveAction                                    required movement behavior @see EMoveComponentAction\n* @param LatentInfo                                    The latent action",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Component",
          "type": "USceneComponent"
        },
        {
          "name": "TargetRelativeLocation",
          "type": "FVector"
        },
        {
          "name": "TargetRelativeRotation",
          "type": "FRotator"
        },
        {
          "name": "bEaseOut",
          "type": "bool"
        },
        {
          "name": "bEaseIn",
          "type": "bool"
        },
        {
          "name": "OverTime",
          "type": "float32"
        },
        {
          "name": "bForceShortestRotationPath",
          "type": "bool"
        },
        {
          "name": "MoveAction",
          "type": "EMoveComponentAction"
        },
        {
          "name": "LatentInfo",
          "type": "FLatentActionInfo"
        }
      ]
    },
    {
      "name": "NormalizeFilename",
      "return": "FString",
      "doc": "Convert all / and \\ to TEXT(\"/\")",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "InFilename",
          "type": "FString"
        }
      ]
    },
    {
      "name": "NotEqual_PrimaryAssetId",
      "return": "bool",
      "doc": "Returns true if the values are not equal (A != B)",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "A",
          "type": "FPrimaryAssetId"
        },
        {
          "name": "B",
          "type": "FPrimaryAssetId"
        }
      ]
    },
    {
      "name": "NotEqual_PrimaryAssetType",
      "return": "bool",
      "doc": "Returns true if the values are not equal (A != B)",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "A",
          "type": "FPrimaryAssetType"
        },
        {
          "name": "B",
          "type": "FPrimaryAssetType"
        }
      ]
    },
    {
      "name": "NotEqual_SoftClassReference",
      "return": "bool",
      "doc": "Returns true if the values are not equal (A != B)",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "A",
          "type": "TSoftClassPtr<UObject>"
        },
        {
          "name": "B",
          "type": "TSoftClassPtr<UObject>"
        }
      ]
    },
    {
      "name": "NotEqual_SoftObjectReference",
      "return": "bool",
      "doc": "Returns true if the values are not equal (A != B)",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "A",
          "type": "TSoftObjectPtr<UObject>"
        },
        {
          "name": "B",
          "type": "TSoftObjectPtr<UObject>"
        }
      ]
    },
    {
      "name": "ParseCommandLine",
      "return": "void",
      "doc": "* Parses the given string into loose tokens, switches (arguments that begin with - or /) and parameters (-mySwitch=myVar)\n*\n* @param        InCmdLine                       The the string to parse (ie '-foo -bar=/game/baz testtoken' )\n* @param        OutTokens[out]          Filled with all loose tokens found in the string (ie: testToken in above example)\n* @param        OutSwitches[out]        Filled with all switches found in the string (ie -foo)\n* @param        OutParams[out]          Filled with all switches found in the string with the format key = value (ie: -bar, /game/baz)",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "InCmdLine",
          "type": "FString"
        },
        {
          "name": "OutTokens",
          "type": "TArray<FString>&"
        },
        {
          "name": "OutSwitches",
          "type": "TArray<FString>&"
        },
        {
          "name": "OutParams",
          "type": "TMap<FString,FString>&"
        }
      ]
    },
    {
      "name": "ParseParam",
      "return": "bool",
      "doc": "Returns true if the string has -param in it (do not specify the leading -)",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "InString",
          "type": "FString"
        },
        {
          "name": "InParam",
          "type": "FString"
        }
      ]
    },
    {
      "name": "ParseParamValue",
      "return": "bool",
      "doc": "Returns 'value' if -option=value is in the string",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "InString",
          "type": "FString"
        },
        {
          "name": "InParam",
          "type": "FString"
        },
        {
          "name": "OutValue",
          "type": "FString&"
        }
      ]
    },
    {
      "name": "PrintString",
      "return": "void",
      "doc": "Prints a string to the log, and optionally, to the screen\nIf Print To Log is true, it will be visible in the Output Log window.  Otherwise it will be logged only as 'Verbose', so it generally won't show up.\n\n@param       InString                The string to log out\n@param       bPrintToScreen  Whether or not to print the output to the screen\n@param       bPrintToLog             Whether or not to print the output to the log\n@param       bPrintToConsole Whether or not to print the output to the console\n@param       TextColor               The color of the text to display\n@param       Duration                The display duration (if Print to Screen is True). Using negative number will result in loading the duration time from the config.\n@param       Key                             If a non-empty key is provided, the message will replace any existing on-screen messages with the same key.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "InString",
          "default": "\"Hello\"",
          "type": "FString"
        },
        {
          "name": "bPrintToScreen",
          "default": "true",
          "type": "bool"
        },
        {
          "name": "bPrintToLog",
          "default": "true",
          "type": "bool"
        },
        {
          "name": "TextColor",
          "default": "FLinearColor ( 0.000000 , 0.660000 , 1.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "Duration",
          "default": "2.000000",
          "type": "float32"
        },
        {
          "name": "Key",
          "default": "NAME_None",
          "type": "FName"
        }
      ]
    },
    {
      "name": "PrintText",
      "return": "void",
      "doc": "Prints text to the log, and optionally, to the screen\nIf Print To Log is true, it will be visible in the Output Log window.  Otherwise it will be logged only as 'Verbose', so it generally won't show up.\n\n@param       InText                  The text to log out\n@param       bPrintToScreen  Whether or not to print the output to the screen\n@param       bPrintToLog             Whether or not to print the output to the log\n@param       bPrintToConsole Whether or not to print the output to the console\n@param       TextColor               The color of the text to display\n@param       Duration                The display duration (if Print to Screen is True). Using negative number will result in loading the duration time from the config.\n@param       Key                             If a non-empty key is provided, the message will replace any existing on-screen messages with the same key.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "InText",
          "type": "FText"
        },
        {
          "name": "bPrintToScreen",
          "default": "true",
          "type": "bool"
        },
        {
          "name": "bPrintToLog",
          "default": "true",
          "type": "bool"
        },
        {
          "name": "TextColor",
          "default": "FLinearColor ( 0.000000 , 0.660000 , 1.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "Duration",
          "default": "2.000000",
          "type": "float32"
        },
        {
          "name": "Key",
          "default": "NAME_None",
          "type": "FName"
        }
      ]
    },
    {
      "name": "QuitEditor",
      "return": "void",
      "doc": "Exit the editor",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "QuitGame",
      "return": "void",
      "doc": "Exit the current game\n@param       SpecificPlayer  The specific player to quit the game. If not specified, player 0 will quit.\n@param       QuitPreference  Form of quitting.\n@param       bIgnorePlatformRestrictions     Ignores and best-practices based on platform (e.g on some consoles, games should never quit). Non-shipping only",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "SpecificPlayer",
          "type": "APlayerController"
        },
        {
          "name": "QuitPreference",
          "type": "EQuitPreference"
        },
        {
          "name": "bIgnorePlatformRestrictions",
          "type": "bool"
        }
      ]
    },
    {
      "name": "RegisterForRemoteNotifications",
      "return": "void",
      "doc": "Requests permission to send remote notifications to the user's device.\n(Android and iOS only)",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "ResetEditorProperty",
      "return": "bool",
      "doc": "Attempts to reset the value of a named property on the given object so that it matches the value of the archetype.\n\n@param Object The object you want to reset a property value on.\n@param PropertyName The name of the object property to reset the value of.\n@param ChangeNotifyMode When to emit property change notifications.\n\n@return Whether the property value was found and correctly reset.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Object",
          "type": "UObject"
        },
        {
          "name": "PropertyName",
          "type": "FName"
        },
        {
          "name": "ChangeNotifyMode",
          "default": "EPropertyAccessChangeNotifyMode :: Default",
          "type": "EPropertyAccessChangeNotifyMode"
        }
      ]
    },
    {
      "name": "ResetGamepadAssignments",
      "return": "void",
      "doc": "Resets the gamepad to player controller id assignments (Android and iOS only)",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "ResetGamepadAssignmentToController",
      "return": "void",
      "doc": "* Resets the gamepad assignment to player controller id (Android and iOS only)",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "ControllerId",
          "type": "int"
        }
      ]
    },
    {
      "name": "RetriggerableDelay",
      "return": "void",
      "doc": "Perform a latent action with a retriggerable delay (specified in seconds).  Calling again while it is counting down will reset the countdown to Duration.\n\n@param WorldContext  World context.\n@param Duration              length of delay (in seconds).\n@param LatentInfo    The latent action.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Duration",
          "type": "float32"
        },
        {
          "name": "LatentInfo",
          "type": "FLatentActionInfo"
        }
      ]
    },
    {
      "name": "SetGamepadsBlockDeviceFeedback",
      "return": "void",
      "doc": "Sets whether attached gamepads will block feedback from the device itself (Mobile only).",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "bBlock",
          "type": "bool"
        }
      ]
    },
    {
      "name": "SetSuppressViewportTransitionMessage",
      "return": "void",
      "doc": "Sets the state of the transition message rendered by the viewport. (The blue text displayed when the game is paused and so forth.)\n\n@param WorldContextObject    World context\n@param State                                 set true to suppress transition message",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "bState",
          "type": "bool"
        }
      ]
    },
    {
      "name": "SetUserActivity",
      "return": "void",
      "doc": "Tells the engine what the user is doing for debug, analytics, etc.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "UserActivity",
          "type": "FUserActivity"
        }
      ]
    },
    {
      "name": "SetVolumeButtonsHandledBySystem",
      "return": "void",
      "doc": "Allows or inhibits system default handling of volume up and volume down buttons (Android only)\n@param       bEnabled                                If true, allow Android to handle volume up and down events",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "bEnabled",
          "type": "bool"
        }
      ]
    },
    {
      "name": "SetWindowTitle",
      "return": "void",
      "doc": "Sets the game window title",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Title",
          "type": "FText"
        }
      ]
    },
    {
      "name": "ShowAdBanner",
      "return": "void",
      "doc": "Will show an ad banner (iAd on iOS, or AdMob on Android) on the top or bottom of screen, on top of the GL view (doesn't resize the view)\n(iOS and Android only)\n\n@param AdIdIndex The index of the ID to select for the ad to show\n@param bShowOnBottomOfScreen If true, the iAd will be shown at the bottom of the screen, top otherwise",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "AdIdIndex",
          "type": "int"
        },
        {
          "name": "bShowOnBottomOfScreen",
          "type": "bool"
        }
      ]
    },
    {
      "name": "ShowInterstitialAd",
      "return": "void",
      "doc": "Shows the loaded interstitial ad (loaded with LoadInterstitialAd)\n(Android only)",
      "ufunction": true,
      "meta": null,
      "args": []
    },
    {
      "name": "ShowPlatformSpecificAchievementsScreen",
      "return": "void",
      "doc": "Displays the built-in achievements GUI (iOS and Android only; this function may be renamed or moved in a future release)\n\n@param SpecificPlayer Specific player's achievements to show. May not be supported on all platforms. If null, defaults to the player with ControllerId 0",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "SpecificPlayer",
          "type": "const APlayerController"
        }
      ]
    },
    {
      "name": "ShowPlatformSpecificLeaderboardScreen",
      "return": "void",
      "doc": "Displays the built-in leaderboard GUI (iOS and Android only; this function may be renamed or moved in a future release)",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "CategoryName",
          "type": "FString"
        }
      ]
    },
    {
      "name": "SnapshotObject",
      "return": "void",
      "doc": "Notify the current transaction (if any) that this object is about to be modified and should be snapshot for intermediate update.\n@note Internally this calls SnapshotTransactionBuffer on the given object.\n@note Only available in the editor.\n\n@param       Object          The object that is about to be modified.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Object",
          "type": "UObject"
        }
      ]
    },
    {
      "name": "SphereOverlapActors",
      "return": "bool",
      "doc": "Returns an array of actors that overlap the given sphere.\n@param WorldContext  World context\n@param SpherePos             Center of sphere.\n@param SphereRadius  Size of sphere.\n@param Filter                Option to restrict results to only static or only dynamic.  For efficiency.\n@param ClassFilter   If set, will only return results of this class or subclasses of it.\n@param ActorsToIgnore                Ignore these actors in the list\n@param OutActors             Returned array of actors. Unsorted.\n@return                              true if there was an overlap that passed the filters, false otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "SpherePos",
          "type": "FVector"
        },
        {
          "name": "SphereRadius",
          "type": "float32"
        },
        {
          "name": "ObjectTypes",
          "type": "TArray<EObjectTypeQuery>"
        },
        {
          "name": "ActorClassFilter",
          "type": "UClass"
        },
        {
          "name": "ActorsToIgnore",
          "type": "TArray<AActor>"
        },
        {
          "name": "OutActors",
          "type": "TArray<AActor>&"
        }
      ]
    },
    {
      "name": "SphereOverlapComponents",
      "return": "bool",
      "doc": "Returns an array of components that overlap the given sphere.\n@param WorldContext  World context\n@param SpherePos             Center of sphere.\n@param SphereRadius  Size of sphere.\n@param Filter                Option to restrict results to only static or only dynamic.  For efficiency.\n@param ClassFilter   If set, will only return results of this class or subclasses of it.\n@param ActorsToIgnore                Ignore these actors in the list\n@param OutActors             Returned array of actors. Unsorted.\n@return                              true if there was an overlap that passed the filters, false otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "SpherePos",
          "type": "FVector"
        },
        {
          "name": "SphereRadius",
          "type": "float32"
        },
        {
          "name": "ObjectTypes",
          "type": "TArray<EObjectTypeQuery>"
        },
        {
          "name": "ComponentClassFilter",
          "type": "UClass"
        },
        {
          "name": "ActorsToIgnore",
          "type": "TArray<AActor>"
        },
        {
          "name": "OutComponents",
          "type": "TArray<UPrimitiveComponent>&"
        }
      ]
    },
    {
      "name": "SphereTraceMulti",
      "return": "bool",
      "doc": "Sweeps a sphere along the given line and returns all hits encountered up to and including the first blocking hit.\nThis trace finds the objects that RESPOND to the given TraceChannel\n\n@param WorldContext  World context\n@param Start                 Start of line segment.\n@param End                   End of line segment.\n@param Radius                Radius of the sphere to sweep\n@param TraceChannel\n@param bTraceComplex True to test against complex collision, false to test against simplified collision.\n@param OutHits               A list of hits, sorted along the trace from start to finish.  The blocking hit will be the last hit, if there was one.\n@return                              True if there was a blocking hit, false otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Start",
          "type": "FVector"
        },
        {
          "name": "End",
          "type": "FVector"
        },
        {
          "name": "Radius",
          "type": "float32"
        },
        {
          "name": "TraceChannel",
          "type": "ETraceTypeQuery"
        },
        {
          "name": "bTraceComplex",
          "type": "bool"
        },
        {
          "name": "ActorsToIgnore",
          "type": "TArray<AActor>"
        },
        {
          "name": "DrawDebugType",
          "type": "EDrawDebugTrace"
        },
        {
          "name": "OutHits",
          "type": "TArray<FHitResult>&"
        },
        {
          "name": "bIgnoreSelf",
          "type": "bool"
        },
        {
          "name": "TraceColor",
          "default": "FLinearColor ( 1.000000 , 0.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "TraceHitColor",
          "default": "FLinearColor ( 0.000000 , 1.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "DrawTime",
          "default": "5.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "SphereTraceMultiByProfile",
      "return": "bool",
      "doc": "Sweep a sphere against the world and return all initial overlaps using a specific profile, then overlapping hits and then first blocking hit\nResults are sorted, so a blocking hit (if found) will be the last element of the array\nOnly the single closest blocking result will be generated, no tests will be done after that\n\n@param WorldContext   World context\n@param Start                  Start of line segment.\n@param End                    End of line segment.\n@param Radius         Radius of the sphere to sweep\n@param ProfileName    The 'profile' used to determine which components to hit\n@param bTraceComplex  True to test against complex collision, false to test against simplified collision.\n@param OutHits                A list of hits, sorted along the trace from start to finish.  The blocking hit will be the last hit, if there was one.\n@return                               True if there was a blocking hit, false otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Start",
          "type": "FVector"
        },
        {
          "name": "End",
          "type": "FVector"
        },
        {
          "name": "Radius",
          "type": "float32"
        },
        {
          "name": "ProfileName",
          "type": "FName"
        },
        {
          "name": "bTraceComplex",
          "type": "bool"
        },
        {
          "name": "ActorsToIgnore",
          "type": "TArray<AActor>"
        },
        {
          "name": "DrawDebugType",
          "type": "EDrawDebugTrace"
        },
        {
          "name": "OutHits",
          "type": "TArray<FHitResult>&"
        },
        {
          "name": "bIgnoreSelf",
          "type": "bool"
        },
        {
          "name": "TraceColor",
          "default": "FLinearColor ( 1.000000 , 0.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "TraceHitColor",
          "default": "FLinearColor ( 0.000000 , 1.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "DrawTime",
          "default": "5.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "SphereTraceMultiForObjects",
      "return": "bool",
      "doc": "Sweeps a sphere along the given line and returns all hits encountered.\nThis only finds objects that are of a type specified by ObjectTypes.\n\n@param WorldContext  World context\n@param Start                 Start of line segment.\n@param End                   End of line segment.\n@param Radius                Radius of the sphere to sweep\n@param ObjectTypes   Array of Object Types to trace\n@param bTraceComplex True to test against complex collision, false to test against simplified collision.\n@param OutHits               A list of hits, sorted along the trace from start to finish.  The blocking hit will be the last hit, if there was one.\n@return                              True if there was a hit, false otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Start",
          "type": "FVector"
        },
        {
          "name": "End",
          "type": "FVector"
        },
        {
          "name": "Radius",
          "type": "float32"
        },
        {
          "name": "ObjectTypes",
          "type": "TArray<EObjectTypeQuery>"
        },
        {
          "name": "bTraceComplex",
          "type": "bool"
        },
        {
          "name": "ActorsToIgnore",
          "type": "TArray<AActor>"
        },
        {
          "name": "DrawDebugType",
          "type": "EDrawDebugTrace"
        },
        {
          "name": "OutHits",
          "type": "TArray<FHitResult>&"
        },
        {
          "name": "bIgnoreSelf",
          "type": "bool"
        },
        {
          "name": "TraceColor",
          "default": "FLinearColor ( 1.000000 , 0.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "TraceHitColor",
          "default": "FLinearColor ( 0.000000 , 1.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "DrawTime",
          "default": "5.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "SphereTraceSingle",
      "return": "bool",
      "doc": "Sweeps a sphere along the given line and returns the first blocking hit encountered.\nThis trace finds the objects that RESPONDS to the given TraceChannel\n\n@param Start                 Start of line segment.\n@param End                   End of line segment.\n@param Radius                Radius of the sphere to sweep\n@param TraceChannel\n@param bTraceComplex True to test against complex collision, false to test against simplified collision.\n@param OutHit                Properties of the trace hit.\n@return                              True if there was a hit, false otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Start",
          "type": "FVector"
        },
        {
          "name": "End",
          "type": "FVector"
        },
        {
          "name": "Radius",
          "type": "float32"
        },
        {
          "name": "TraceChannel",
          "type": "ETraceTypeQuery"
        },
        {
          "name": "bTraceComplex",
          "type": "bool"
        },
        {
          "name": "ActorsToIgnore",
          "type": "TArray<AActor>"
        },
        {
          "name": "DrawDebugType",
          "type": "EDrawDebugTrace"
        },
        {
          "name": "OutHit",
          "type": "FHitResult&"
        },
        {
          "name": "bIgnoreSelf",
          "type": "bool"
        },
        {
          "name": "TraceColor",
          "default": "FLinearColor ( 1.000000 , 0.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "TraceHitColor",
          "default": "FLinearColor ( 0.000000 , 1.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "DrawTime",
          "default": "5.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "SphereTraceSingleByProfile",
      "return": "bool",
      "doc": "Sweep a sphere against the world and return the first blocking hit using a specific profile\n\n@param Start                  Start of line segment.\n@param End                    End of line segment.\n@param Radius                 Radius of the sphere to sweep\n@param ProfileName    The 'profile' used to determine which components to hit\n@param bTraceComplex  True to test against complex collision, false to test against simplified collision.\n@param OutHit                 Properties of the trace hit.\n@return                               True if there was a hit, false otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Start",
          "type": "FVector"
        },
        {
          "name": "End",
          "type": "FVector"
        },
        {
          "name": "Radius",
          "type": "float32"
        },
        {
          "name": "ProfileName",
          "type": "FName"
        },
        {
          "name": "bTraceComplex",
          "type": "bool"
        },
        {
          "name": "ActorsToIgnore",
          "type": "TArray<AActor>"
        },
        {
          "name": "DrawDebugType",
          "type": "EDrawDebugTrace"
        },
        {
          "name": "OutHit",
          "type": "FHitResult&"
        },
        {
          "name": "bIgnoreSelf",
          "type": "bool"
        },
        {
          "name": "TraceColor",
          "default": "FLinearColor ( 1.000000 , 0.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "TraceHitColor",
          "default": "FLinearColor ( 0.000000 , 1.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "DrawTime",
          "default": "5.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "SphereTraceSingleForObjects",
      "return": "bool",
      "doc": "Sweeps a sphere along the given line and returns the first hit encountered.\nThis only finds objects that are of a type specified by ObjectTypes.\n\n@param Start                 Start of line segment.\n@param End                   End of line segment.\n@param Radius                Radius of the sphere to sweep\n@param ObjectTypes   Array of Object Types to trace\n@param bTraceComplex True to test against complex collision, false to test against simplified collision.\n@param OutHit                Properties of the trace hit.\n@return                              True if there was a hit, false otherwise.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Start",
          "type": "FVector"
        },
        {
          "name": "End",
          "type": "FVector"
        },
        {
          "name": "Radius",
          "type": "float32"
        },
        {
          "name": "ObjectTypes",
          "type": "TArray<EObjectTypeQuery>"
        },
        {
          "name": "bTraceComplex",
          "type": "bool"
        },
        {
          "name": "ActorsToIgnore",
          "type": "TArray<AActor>"
        },
        {
          "name": "DrawDebugType",
          "type": "EDrawDebugTrace"
        },
        {
          "name": "OutHit",
          "type": "FHitResult&"
        },
        {
          "name": "bIgnoreSelf",
          "type": "bool"
        },
        {
          "name": "TraceColor",
          "default": "FLinearColor ( 1.000000 , 0.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "TraceHitColor",
          "default": "FLinearColor ( 0.000000 , 1.000000 , 0.000000 , 1.000000 )",
          "type": "FLinearColor"
        },
        {
          "name": "DrawTime",
          "default": "5.000000",
          "type": "float32"
        }
      ]
    },
    {
      "name": "TransactObject",
      "return": "void",
      "doc": "Notify the current transaction (if any) that this object is about to be modified and should be placed into the undo buffer.\n@note Internally this calls Modify on the given object, so will also mark the owner package dirty.\n@note Only available in the editor.\n\n@param       Object          The object that is about to be modified.",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "Object",
          "type": "UObject"
        }
      ]
    },
    {
      "name": "UnloadPrimaryAsset",
      "return": "void",
      "doc": "Unloads a primary asset, which allows it to be garbage collected if nothing else is referencing it",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "PrimaryAssetId",
          "type": "FPrimaryAssetId"
        }
      ]
    },
    {
      "name": "UnloadPrimaryAssetList",
      "return": "void",
      "doc": "Unloads a primary asset, which allows it to be garbage collected if nothing else is referencing it",
      "ufunction": true,
      "meta": null,
      "args": [
        {
          "name": "PrimaryAssetIdList",
          "type": "TArray<FPrimaryAssetId>"
        }
      ]
    },
    {
      "name": "UnregisterForRemoteNotifications",
      "return": "void",
      "doc": "Requests Requests unregistering from receiving remote notifications to the user's device.\n(Android only)",
      "ufunction": true,
      "meta": null,
      "args": []
    }
  ]
}